[{"title":"Java基础语法","url":"/2022/07/28/Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/","content":"注意\nvscode默认为UTF-8编码，使用时候右下角改为GBK在进行javac的时候就不会中文报错\n\n中文操作系统默认的编码是GBK，javac命令不指定-encoding选项时，以系统默认的编码GBK来解析源代码文件，源代码文件的编码如果不是GBK，那就会报错。 如果源代码是UTF-8编码，那javac命令要指定-encoding： javac -encoding UTF-8 demo01.java\nJava面向对象的三大特性\n封装\n继承\n多态\n\nJava数据类型字符型(char)char最大的优势也就在于中文处理。\njava使用的是unicode这种十六进制的编码,可以包括任意的文字内容。\n布尔型(boolean)布尔型描述的是逻辑的处理结果。\nJava的布尔类型的取值范围只有：true，false。\n定义布尔型数据\nboolean flag = true;\n\nString字符串(String)字符串之间可以通过 + 来进行连接。\nString str = &quot;hello&quot;;//注意S是大写str = str + &quot; world&quot;;str += &quot; !!!&quot;;//hello world !!!\n\n在Java语言里面，两个不同数据类型进行计算，范围小的数据类型自动转型为范围大的数据类型，若计算类型包裹String类型，则所有的类型无条件先变为String,如果有“+”表示的就是字符串连接。\ndouble x = 20.1;int y = 10;String str = x + y;//20.110\n\n在描述字符串的时候也可以使用转义字符进行一些处理，例如:TAB ( t)、”(&quot;)、’(&#39;)、换行、( \\n)、(\\)。\nJava运算符位运算·&amp;和|两个运算符可以进行位运算与逻辑运算；\n |-在进行逻辑运算的时候所有的判断条件都要执行；\n |-在进行位运算的时候只是针对于当前的数据进行与和或处理；\n· 在逻辑运算上还可以使用&amp;&amp;、||；\n |-&amp;&amp;:在若干个条件判断的时候，如果前面的条件返回了false,后续所有的条件都不再判断最终的结果就是false;\n |-||：在若干个条件判断的时候，如果前面的条件返回了true,后续条件不再执行，最终就是true.\n条件运算符(三元运算符)该运算符有3个操作数，并且需要判断布尔表达式的值。\n作用：判断哪个值应该赋值给变量。\n//variable x = (expression) ? value if true : value if falsepublic class Demo &#123;   public static void main(String[] args)&#123;      int a , b;      a = 10;      // 如果 a 等于 1 成立，则设置 b 为 20，否则为 30      b = (a == 1) ? 20 : 30;      System.out.println( &quot;Value of b is : &quot; +  b );//30       // 如果 a 等于 10 成立，则设置 b 为 20，否则为 30      b = (a == 10) ? 20 : 30;      System.out.println( &quot;Value of b is : &quot; + b );//20   &#125;&#125;\n\n运行结果如下\nValue of b is : 30Value of b is : 20\n\n关系运算符所有的关系运算返回的判断结果都是布尔型数据\n尝试像C语言一样使用int型数据类型接收结果会报错：boolean无法转换为int\ninstanceof 运算符/*该运算符用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）。\n( Object reference variable ) instanceof  (class/interface type)\n\n如果运算符左侧变量所指的对象，是操作符右侧类或接口(class/interface)的一个对象，那么结果为真。\nString name = &quot;James&quot;;boolean result = name instanceof String; // 由于 name 是 String 类型，所以返回真\n\nJava运算符优先级\n\n\n类别\n操作符\n关联性\n\n\n\n后缀\n() [] . (点操作符)\n左到右\n\n\n一元\nexpr++ expr–\n从左到右\n\n\n一元\n++expr –expr + - ～ ！\n从右到左\n\n\n乘性\n* /％\n左到右\n\n\n加性\n+ -\n左到右\n\n\n移位\n&gt;&gt; &gt;&gt;&gt;  &lt;&lt;\n左到右\n\n\n关系\n&gt; &gt;= &lt; &lt;=\n左到右\n\n\n相等\n== !=\n左到右\n\n\n按位与\n＆\n左到右\n\n\n按位异或\n^\n左到右\n\n\n按位或\n|\n左到右\n\n\n逻辑与\n&amp;&amp;\n左到右\n\n\n逻辑或\n| |\n左到右\n\n\n条件\n？：\n从右到左\n\n\n赋值\n= + = - = * = / =％= &gt;&gt; = &lt;&lt; =＆= ^ = | =\n从右到左\n\n\n逗号\n，\n左到右\n\n\nJava程序逻辑控制for循环for(初始化; 布尔表达式; 更新) &#123;    //代码语句&#125;\n\nfor循环执行的次数是在执行前就确定的。语法格式如下：\nfor(初始化; 布尔表达式; 更新) {    //代码语句 }\n语句先后顺序\n\n初始化 ；\n判断布尔表达式，为false会退出循环；为true会执行代码语句 ；\n更新 ；\n回到第二部 ；\n\njava增强for循环版本：Java5及以上版本才有\n语法格式如下:\nfor(声明语句 : 表达式) &#123;   //代码句子 &#125;\n声明语句：声明新的和数组元素的类型匹配的局部变量。其作用域限定在循环语句块，其值与此时数组元素的值相等。\n表达式：表达式是要访问的数组名，或者是返回值为数组的方法。\n实例Test.java 文件代码：public class Test &#123;   public static void main(String args[])&#123;      int [] numbers = &#123;10, 20, 30, 40, 50&#125;;       for(int x : numbers )&#123;         System.out.print( x );         System.out.print(&quot;,&quot;);      &#125;      System.out.print(&quot;\\n&quot;);      String [] names =&#123;&quot;James&quot;, &quot;Larry&quot;, &quot;Tom&quot;, &quot;Lacy&quot;&#125;;      for( String name : names ) &#123;         System.out.print( name );         System.out.print(&quot;,&quot;);      &#125;   &#125;&#125;\n\n输出结果\n10,20,30,40,50,James,Larry,Tom,Lacy,\n\nJava程序逻辑控制：Swith开关语句与C语言不同：可判断字符串(String)。\nbreak 关键字break 用在循环或者 switch 语句中，可跳出最内层的整个语句块，并继续执行该语句块下面的语句。\ncontinue 关键字continue 适用于任何循环控制结构中。作用是让程序立刻跳转到下一次循环的迭代。\n注意：在 for 循环中，continue 语句使程序立即跳转到更新语句。\nJava语言支持一些特殊的转义字符序列。\n\n\n符号\n字符含义\n\n\n\n\\n\n换行 (0x0a)\n\n\n\\r\n回车 (0x0d)\n\n\n\\f\n换页符(0x0c)\n\n\n\\b\n退格 (0x08)\n\n\n\\0\n空字符 (0x0)\n\n\n\\s\n空格 (0x20)\n\n\n\\t\n制表符\n\n\n&quot;\n双引号\n\n\n&#39;\n单引号\n\n\n\\\n反斜杠\n\n\n\\ddd\n八进制字符 (ddd)\n\n\n\\uxxxx\n16进制Unicode字符 (xxxx)\n\n\n方法的定义与使用方法重载在一个类中，多个方法的方法名相同，但是参数列表不同。\n同一个方法名称但是可以根据调用时传递的不同参数的类型或个数实现不同方法体的调用。\npublic class JavaDemo&#123;    public static void main(String args[])&#123;        int resultA = sum(10,20);        int resultB = sum(10,20,30);        double resultC = sum(10.2,20.3);        System.out.println(&quot;resultA=&quot;+resultA);        System.out.println(&quot;resultB=&quot;+resultB);        System.out.println(&quot;resultC=&quot;+resultC);    &#125;    public static int sum(int x,int y)&#123;        return x + y;    &#125;    public static int sum(int x,int y,int z)&#123;        return x + y + z;    &#125;    public static double sum(double x,double y)&#123;        return x + y ;    &#125;&#125;\n\n类面向对象简介三个主要特征\n封装性：内部的操作对外部不可见;\n继承性：在已有结构的基础上继续进行功能的扩充；很像游戏mod\n多态性：是在继承性的基础上扩充而来的概念，指得是类型的转换处理。(方法重载就体现多态性)\n\n三个步骤：\nOOA：面向对象分析；(Object-oriented analysis)\nOOD：面向对象设计；(Object-oriented design)\nOOP：面向对象编程；(Object-oriented programming)\n\n类与对象简介类是对某一事物的共性的抽象概念，而对象描述的是一个具体的产物。\n类是一个模板，而对象才是类可以使用的实例，先有类再有对象。\n类之中一般有两个组成：\n\n成员属性(Field)：就是变量 ;\n操作方法(Method)：定义对象具有的处理行为；(很像函数)\n\n类与对象的定义与使用类名的首字母必须大写\n类是一个独立的结构体，所以需要使用class来进行定义(这点不是很懂)\nclass类用来描述一个类的类型，可以通过反射api访问它，在运行时获得一个类型有什么字段、函数、实现了什么接口等，并且动态创建它。\nclass Person &#123;//定义一个类    String name ;    int age ;    public void tell() &#123;        System.out.println(&quot;姓名：&quot; + name + &quot;、年龄：&quot; + age) ;    &#125;&#125;\n\n在这个类之中定义有两个属性name、age和一个方法tell()\n如果想要使用这个类需要使用对象来完成，对象的产生需要使用下面语法格式完成。\n声明对象\n声明并实例化对象：类名称 对象名称 = new 类名称();\n\n分步骤完成：\n\n声明对象：类名称 对象名称 = null；\n实例化对象：对象名称 = new 类名称()。\n\n\n\nclass Person &#123;\t//定义一个类    String name ;    int age ;    public void tell() &#123;        System.out.println(&quot;姓名：&quot; + name + &quot;、年龄：&quot; + age) ;    &#125;&#125;public class Demo() &#123;    public static void main(String[] args) &#123;        Person per = new Person() ;//声明并实例化对象    &#125;&#125;\n\n类的调用\n调用类中属性：实例化对象.成员属性\n\n调用类中方法：实例化对象.方法名称()\n\n\nclass Person&#123;    String name;    int age;    public void tell()&#123;        System.out.println(&quot;姓名:&quot;+ name +&quot;\\n&quot;+&quot;年龄：&quot;+ age);    &#125;&#125;public class Demo &#123;    public static void main(String args[]) &#123;        Person per = new Person();//声明并实例化对象        per.age=18;        per.name = &quot;kouber&quot;;        per.tell();//进行方法的调用    &#125;&#125;输出结果：姓名:kouber年龄：18\n\n如果没有对属性内容设置，则该数据内容为该数据类型的默认值\nclass Person&#123;    String name;    int age;    public void tell()&#123;        System.out.println(&quot;姓名:&quot;+ name +&quot;\\n&quot;+&quot;年龄：&quot;+ age);    &#125;&#125;public class Demo &#123;    public static void main(String args[]) &#123;        Person per = new Person();//声明并实例化对象        per.tell() ;    &#125;&#125;输出结果：姓名:null年龄：0\n\n对象的内存分析堆栈内存\n堆内存：保存对象的具体信息，堆内存空间的开辟是通过new完成的。\n栈内存：保存的是一块堆内存的地址，即：通过地址找到堆内存，然后找到对象内容\n\n声明可以理解为在栈内存空间里面有了一个名称(但还没有堆内存的指向，就是一个变量名字，没什么卵用)\n(有声明的)实例化则是在堆中开辟一块空间并将名称指向这片空间\nnew的出现即为新的堆内存的出现\nclass Person&#123;    String name;    int age;    public void tell()&#123;        System.out.println(&quot;姓名:&quot;+ name +&quot;\\n&quot;+&quot;年龄：&quot;+ age);    &#125;&#125;public class Demo &#123;    public static void main(String args[]) &#123;        Person perA = new Person();//声明并实例化对象        //堆和栈中都开辟了空间                Person perB = null ;//声明但未实例化对象        //栈中出现了perB，但是其指向为空，此时并未新建堆空间        perB = new Person() ;//实例化对象        //new开辟了一块新的堆内存空间并将栈中的perB指向了该空间的地址        &#125;&#125;输出结果：姓名:null年龄：0\n\n对象必须实例化之后才能使用否则无法使用\nclass Person&#123;    String name;    int age;    public void tell()&#123;        System.out.println(&quot;姓名:&quot;+ name +&quot;\\n&quot;+&quot;年龄：&quot;+ age);    &#125;&#125;public class Demo &#123;    public static void main(String args[]) &#123;        Person per = null ;//声明但未实例化对象        per.age=18;//报错：java.lang.NullPointerException    &#125;&#125;\n\n对象引用传递分析类本身属于引用数据类型\n引用传递的本质：同一块堆内存空间可以被不同的栈内存所指向，也可以更换指向。\n引用传递perA和perB指向的是同一块堆内存空间\nclass Person&#123;    String name;    int age;    public void tell()&#123;        System.out.println(&quot;姓名:&quot;+ name +&quot;\\n&quot;+&quot;年龄：&quot;+ age);    &#125;&#125;public class Demo &#123;    public static void main(String args[]) &#123;        Person perA = new Person();//声明并实例化对象        perA.age=18;        perA.name = &quot;kouber&quot;;        Person perB = perA ;//引用传递        perB.age = 80 ;        perA.tell();    &#125;&#125;输出结果：姓名:kouber年龄：80\n\n发生在方法上的引用传递这个时候一定要观察方法的参数类型，同时也要观察方法的执行过程。\ntemp和per指向的是同一块内存空间\nchange()方法传递的是per指向的堆内存空间的地址\nclass Person&#123;    String name;    int age;    public void tell()&#123;        System.out.println(&quot;姓名:&quot;+ name +&quot;\\n&quot;+&quot;年龄：&quot;+ age);    &#125;&#125;public class Demo &#123;    public static void main(String args[]) &#123;        Person per = new Person();//声明并实例化对象        per.age=18;        per.name = &quot;kouber&quot;;        change(per) ;        per.tell();    &#125;&#125;public class change(Person temp) &#123;    temp.age = 80 ;&#125;输出结果：姓名:kouber年龄：80\n\n垃圾空间Person perA = new Person() ;Person perB = new Person() ;perA = perB ;\n\nperA指向了perB那么perA本身指向的堆内存空间就被丢弃了，这片空间就是垃圾空间。\n垃圾空间就是没有任何栈内存指向的堆内存空间，所有的垃圾将被GC(Garbage Collector、垃圾收集器)定期进行回收并且释放无用空间，但是如果垃圾过多，一定将影响到GC的处理性能，从而降低整体的程序性能，实际开发中尽量少产生垃圾空间。\n深入分析类与对象成员属性封装类中属性可通过其他类利用对象进行调用的。\n利用private对属性进行封装处理后，类内部的属性只对内部可见，对外部不可见，即不能在类外直接修改类private属性，但可调用类内修改private属性的方法进行修改。\n构造方法与匿名对象构造方法：对类的对象的属性进行初始化定义要求如下：\n\n构造方法名称必须与类名称一致\n构造方法不允许设置任何的返回值类型；即没有返回值定义\n构造方法是在使用关键字new实例化对象的时候自动调用的\n\n类中一定会有一个构造方法，如果没有明确定义，系统会自动创建一个无参的构造方法\n构造方法如何使用class Message &#123;    private String title ;    public Message (String t)&#123;//定义有参构造        title = t;    &#125;     public String getTitle()&#123;        return title;    &#125;    public void setTitle(String t) &#123;        title = t;    &#125;&#125;class Person &#123;\t//定义一个类    private String name ;    private int age;    public Person (Message msg,int a)&#123; //定义有参构造        name = msg.getTitle();\t//为类中的属性赋值（初始化）        age = a;\t//为类中的属性赋值（初始化）    &#125;    public Message getInfo() &#123;        return new Message(name + &quot; : &quot; + age);    &#125;    public void tell() &#123;        System.out.println(&quot;姓名：&quot;+ name +&quot;、年龄：&quot; + age);   \t&#125;&#125;public class Demo &#123; //主类    public static void main(String args[])&#123;        Message msg = new Message(&quot;mldn&quot;);//使用构造方法进行初始化赋值        Person per = new Person(msg,20);//使用构造方法进行初始化赋值        msg = per.getInfo();        System.out.println(msg.getTitle());    &#125;&#125;运行结果：mldn : 20\n\n匿名对象的使用用完直接扔\nclass Person &#123;\t//定义一个类    private String name ;    private int age;    public Person (String name,int a)&#123; //定义有参构造        this.name = name;\t//为类中的属性赋值（初始化）        age = a;\t//为类中的属性赋值（初始化）    &#125;    public void tell() &#123;        System.out.println(&quot;姓名：&quot;+ name +&quot;、年龄：&quot; + age);   \t&#125;&#125;public class Demo&#123;    public static void main(String args[])&#123;        new Person(&quot;Kouber&quot;，18).tell;//进行方法的调用    &#125;&#125;运行结果：姓名：Kouber、年龄：18\n\n此对象没有引用(没有名字)，使用后会变成垃圾，所有的垃圾将被GC进行回收与释放\nthis关键字使用this调用方法除了调用属性之外，this也可以实现方法的调用，但是对于方法的调用就必须考虑构造与普通方法\n\n构造方法调用this();使用关键字new实例化对象的时候才会调用构造方法；\n普通方法调用this.方法名称()；\n\nthis实现构造方法互相调用class Person&#123;\tprivate String name;\tprivate int age;\tpublic Person() &#123;\t\tSystem.out.println(&quot;**************&quot;);\t&#125;\t\tpublic Person(String name) &#123;\t\tthis();//调用本类中的无参构造\t\tthis.name=name;\t&#125;\tpublic Person(String name,int age) &#123;\t\tthis(name);//调用本类中的有参构造\t\tthis.age=age;\t\t&#125;\tpublic String getInfo() &#123;\t\treturn &quot;姓名： &quot;+this.name+&quot;  年龄：&quot;+this.age;\t&#125;&#125;    public class Demo &#123;        public static void main(String args[]) &#123;            System.out.println(new Person().getInfo());            System.out.println(new Person(&quot;张三&quot;).getInfo());            System.out.println(new Person(&quot;张三&quot;,20).getInfo());        &#125;&#125;\t\n\n需要注意以下三点\n\n“this()”的语句只允许放在构造方法的首行\n在构造方法中能调用普通方法，反过来普通方法不能调用构造方法；**this()不能在普通方法中使用**\n构造方法互相调用时请保留有程序的出口，别形成死循环；\n\n简单Java类核心开发结构：\n\n类名称一定要有意义，可以明确的描述某一类事物；\n类之中的所有属性都必须使用private进行封装，同时封装后的属性必须要提供有setter、getter方法；\n类之中可以提供有无数多个构造方法，但是必须要保留有无参构造方法\n类之中不允许出现任何的输出语句，所有内容的获取必须返回\n【非必须】可以提供有一个获取对象详细信息的方法，暂时将此方法名称定义为getInfo()\n\nclass Dept &#123;    private long deptno ;    private String dname ;    private String loc;    public Dept() &#123;&#125;    public Dept(long deptno,String dname,String loc) &#123;        this.deptno = deptno ;        this.dname = dname ;        this.loc = loc ;     &#125;    public String getInfo() &#123;        return &quot;【部门信息】部门编号：&quot; + this.deptno + &quot;、部门名称 &quot; + this.dname + &quot;、部门位置 ：&quot; + this.loc ;    &#125;    public void setDeptno(long deptno) &#123;        this.deptno = deptno;    &#125;    public void setDname(String dname) &#123;        this.dname = dname ;    &#125;    public void setLoc(String loc) &#123;        this.loc = loc ;    &#125;&#125;public class Demo &#123;    public static void main(String args[]) &#123;        Dept dept = new Dept(10,&quot;技术部&quot;,&quot;北京&quot;);        System.out.println(dept.getInfo());    &#125;&#125;\n\nstatic所有的static定义的属性和方法都可以在没有实例化对象的前提下使用\nstatic属性可以由类名称直接调用类名称.(static)属性 = （赋值）n\nstatic属性虽然定义在类之中，但是其并不受到类实例化对象的控制。\n\n考虑到公共信息储存的时候才会使用到static属性\n\nstatic方法和非static方法调用上的限制\nstatic方法只允许调用static属性或static方法\n非static方法允许调用static属性或static方法\n\n但在static方法中调用非static方法可以通过对象来调用\npublic class Demo &#123;    public static void main(String args[]) &#123;        new Demo().print() ; // 此处Demo后需要加上括号    &#125;    public void print() &#123;        System.out.println(&quot;www.pintia.cn&quot;) ;//www.pintia.cn    &#125;&#125;\n\nstatic只有在回避实例化对象调用并且描述公共属性的情况下才会考虑\n代码块构造块构造代码块：是给所有的对象进行初始化，也就是说，所有的对象都会调用一个代码块，只要对象一建立，就会调用这个代码块。\nclass Client &#123;    &#123;//构造代码块        System.out.println(&quot;执行构造代码块&quot;);    &#125;    public Client() &#123;        System.out.println(&quot;执行无参构造函数&quot;);    &#125;    public Client(String string) &#123;        System.out.println(&quot;执行有参构造函数&quot;);    &#125;&#125;public class Demo &#123;    public static void main(String[] args) &#123;        Client client = new Client(&quot;XXX&quot;) ;    &#125;&#125;//输出结果//执行构造代码块//执行有参构造函数\n\n静态代码块主要目的:静态属性的初始化。\n执行优先级高于非静态的初始化块，它会在类初始化的时候执行一次，执行完成便销毁，它仅能初始化类变量，即static修饰的数据成员\n静态代码块比主方法先执行\npublic class Demo &#123;    static &#123;   \t\tSystem.out.println(&quot;静态代码块：最高优先级&quot;) ;       &#125;    public static void main(String args[]) &#123;        System.out.println(&quot;主方法代码块：执行次于静态代码块&quot;) ;    &#125;&#125;执行结果：静态代码块：最高优先级主方法代码块：执行次于静态代码块\n\n非静态代码块执行的时候如果有静态初始化块，先执行静态初始化块再执行非静态初始化块，在每个对象生成时都会被执行一次，它可以初始化类的实例变量。非静态初始化块会在构造函数执行时，在构造函数主体代码执行之前被运行。\n代码块执行顺序静态代码块—–&gt;非静态代码块——–&gt;构造函数\n数组定义语法\n数组的动态初始化，初始化之后数组每一个元素的保存内容为其对应数据类型的默认值\n声明并初始化数组：\n数据类型 数组名称 [] = new 数据类型 [长度] ；\n数据类型 [] 数组名称 = new 数据类型 [长度] ；\n\n\n\n\n\npublic class Demo &#123;    public static void main (String args[]) &#123;        int a [] = new int [10] ;        int [] b = new int [10] ;    &#125;&#125;\n\n\n\n\n数组的静态初始化：在数组定义的时候就为其设置好了里面的内容：\n简化格式：数据类型 数组名称 [] = {数据类型 1，数据类型 2，数据类型 3，···};\n完整格式：数据类型 数组名称 [] = new 数据类型 [] {数据类型 1，数据类型 2，数据类型 3，···}; (黑体部分：匿名数组)\n老师强烈建议用完整格式进行数组的初始化\n\n\n\n当使用数组下标超出数组范围时候，程序编译会有此报错\nArrayIndexOutOfBoundsException\n意味数组越界\n求数组长度： 数组名.lengthpublic class Demo &#123;    public static void main(String args[]) &#123;        int [] data = new int [3] ;        System.out.print(data.length) ;    &#125;&#125;结果输出：3\n\n增强型for循环：foreach（迭代输出）利用foreach的语法结构可以直接自动获取数组中的每一个元素，避免下标访问\nfor(数据类型 变量 : 数组 | 集合) &#123;&#125;\n实质：自动将数组中每个元素取出用变量temp保存\npublic class Demo &#123;\tpublic static void main(String args[]) &#123;\t\tint [] data = new int [] &#123;1,2,3,4,5&#125; ;\t\tfor (int temp : data) &#123;\t\t\tSystem.out.print(temp) ;\t\t&#125;\t&#125;&#125;输出结果：12345\n\n引用数据类型内存分析（数组）引用数据类型：必须在为之开辟了堆内存空间之后才可以使用。\npublic class Demo &#123;    public static void main(String args[]) &#123;        int [] data = new int [] &#123;10,20,30&#125; ; //静态初始化        int [] temp = data ; //引用传递        temp [0] = 100 ;        for (int x = 0 ; x &lt; data.length ; x++) &#123;            System.out.print(data[x] ) ;        &#125;    &#125;&#125;输出结果：100 20 30 \n\n两者的数据本质上是同一个堆内存里面的数据\n由于数组属于引用类型，所以一定要为其开辟堆内存空间之后才可以使用，如果现在使用了未开辟空间的数组，会出现NullPointerException（数组）\n例：\npublic class Demo &#123;    public static void main &#123;        int [] data = null ;        System.out.print(data[0]) ;    &#125;&#125;正常编译但是运行会出现**NullPointerException**报错\n\n因此：数组必须提供有实例化对象才可与使用数组的操作形式进行数组的操作\n方法传递数组public class Demo&#123;    public static void main(String args[])&#123;        int data [] = initArray();        printArray(data);//传递数组    &#125;    public static int [] initArray() &#123;        int arr [] = new int [] &#123;1,2,3,4,5&#125;;        return arr;//返回一个数组    &#125;    //要求接受一个int型的数组    public static void printArray(int temp []) &#123;        for(int x = 0 ; x &lt; temp.length ; x++)&#123;            System.out.print(temp[x]、) ;        &#125;    &#125;&#125;输出结果：1、2、3、4、5、\n\n二维数组定义语法\n\n数组的动态初始化：\n\n数据类型 [] [] 数组名称 = new 数据类型 [行个数] [列个数] ;\n\n\n数组的静态初始化：\n\n数据类型 数组名称 [] [] = new 数据类型 [] [] { {数据，数据，···},{数据，数据，···} } ;\n\n\n\npublic class Demo &#123;    public static void main(String args[]) &#123;        int [] [] data = new int [] [] &#123; &#123;1,2,3,4,5&#125;,&#123;1,2,3&#125;,&#123;5,6,7,8&#125; &#125; ;        for(int x = 0 ; x &lt; data.length ; x ++) &#123; //这里的data.length = 3             for(int y = 0 ;y &lt; data[x].length ; y ++)&#123;                System.out.println(&quot;data[&quot;+x+&quot;][&quot;+y+&quot;]=&quot;+data[x][y]) ;            &#125;            System.out.println() ;        &#125;    &#125;&#125;输出结果：data[0][0]=1data[0][1]=2data[0][2]=3data[0][3]=4data[0][4]=5data[1][0]=1data[1][1]=2data[1][2]=3data[2][0]=5data[2][1]=6data[2][2]=7data[2][3]=8\n\n使用foreach输出该二维数组\npublic class Demo &#123;    public static void main(String args[]) &#123;        int [] [] data = new int [] [] &#123; &#123;1,2,3,4,5&#125;,&#123;1,2,3&#125;,&#123;5,6,7,8&#125; &#125; ;        for(int temp [] : data) &#123; //这里的data.length = 3             for(int num : temp)&#123;                System.out.print(num + &quot;、&quot;) ;            &#125;            System.out.println() ;        &#125;    &#125;&#125;输出结果：1、2、3、4、5、1、2、3、5、6、7、8、\n\n通过foreach可以看出，二维数组就是数组的嵌套使用\n数组相关类库数组排序：*java.until.Arrays.sort(数组名称);*（升序）\n数组拷贝：System.arraycopy(原数组，原数组开始点，目标数组，目标数组开始点，拷贝长度);\n方法可变参数\n可变参数，会被编译器转型为一个数组\n可变参数只能作为函数的最后一个参数，所以一个函数最多只能有一个可变参数\n可变参数在编译为字节码后，在方法签名中就是以数组形态出现的。这两个方法的签名是一致的，不能作为方法的重载。如果同时出现，是不能编译通过的。可变参数可以兼容数组，反之则不成立\n\nclass ArrayUtil &#123;    public static int sum(int [] data) &#123;        int sum = 0 ;        for(int temp : data) &#123;            sum += temp ;        &#125;        return sum ;    &#125;&#125;public class Demo&#123;\tpublic static void main(String args[]) &#123;        System.out.print(ArrayUtil.sum(new int [] &#123;1,2,3&#125;)) ;    \t//上面如果是这样(new [] int &#123;1,2,3&#125;) ;则会出现报错        //错误: 需要&lt;标识符&gt; System.out.println(ArrayUtil.sum(new^(此处标出错误)[] int &#123;1,2,3&#125;)) ;    &#125;&#125;输出结果：6\n\nclass ArrayUtil &#123;    public static int sum(int ... data) &#123;        int sum = 0 ;        for(int temp : data) &#123;            sum += temp ;        &#125;        return sum ;    &#125;&#125;public class Demo&#123;\tpublic static void main(String args[]) &#123;        System.out.printl(ArrayUtil.sum(1，2，3)) ;    &#125;&#125;输出结果：6\n\njava输入方式一、从键盘获取不限制长度的数组splitsplit() 方法根据匹配给定的正则表达式来拆分字符串。\n注意： . 、 **$**、 | 和 ***** 等转义字符，必须得加 \\\\。\n注意：多个分隔符，可以用 | 作为连字符。\nimport java.util.Scanner;public class Demo &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;请输入几个数并用“.”隔开:&quot;);        Scanner sc = new Scanner(System.in);//从键盘接收数据        String str = sc.next().toString();//next()方式接收字符串        System.out.println(str);        String [] arr  = str.split(&quot;\\\\.&quot;);        for(int j = 0; j&lt;arr.length;j++) &#123;          System.out.print(arr[j]+&quot; &quot;);        &#125;    &#125;&#125;\n\n二、从键盘获取限制长度的数组import java.util.Scanner;public class InputArrayLimitLength &#123;\tpublic static void main(String[] args) &#123;\t\tScanner scanner = new Scanner(System.in);\t\tint n = scanner.nextInt();\t\tSystem.out.println(&quot;请输入&quot;+n+&quot;个数：&quot;);\t\tScanner sc = new Scanner(System.in);\t\tint[] b=new int[n];\t\tfor(int i=0;i&lt;b.length;i++)&#123;\t\t\tb[i]=sc.nextInt();\t\t\tSystem.out.print(&quot; &quot; + b[i]);\t\t&#125;\t&#125;&#125;\n\n\n\n\n\n引用传递实际应用类关联结构代码链class Car &#123;    private String name ;    private double price ;    private Person person ;//一辆车属于一个人    public Car(String name,double price) &#123;        this.name = name ;        this.price = price ;    &#125;    public void setPerson(Person person) &#123;        this.person = person ;    &#125;    public Person getPerson() &#123;        return this.person ;     &#125;    public String getInfo() &#123;        return &quot;汽车品牌号&quot; + this.name + &quot;、汽车价格:&quot; + this.price ;    &#125;&#125;class Person &#123;    private String name ;    private int age ;    private Car car ;//一个人有一辆车    public Person(String name,int age) &#123;        this.name = name ;        this.age = age ;    &#125;    public void setCar(Car car) &#123;        this.car = car ;    &#125;    public Car getCar() &#123;        return this.car ;    &#125;    public String getInfo() &#123;        return &quot;姓名：&quot; + this.name + &quot;、年龄：&quot; + this.age ;    &#125;&#125;public class Demo &#123;    public static void main(String args[]) &#123;        //声明对象并且设置彼此的关系        Person person = new Person(&quot;Mr.lin&quot;,29) ;        Car car = new Car(&quot;binli&quot;,10) ;        person.setCar(car) ;//一个人有一辆车        car.setPerson(person) ;//一辆车属于一个人        //第二部：根据关系获取数据        System.out.println(person.getCar().getInfo()) ;//代码链        System.out.println(car.getPerson().getInfo()) ;//代码链    &#125;&#125;\n\n自身关联class Car &#123;    private String name ;    private double price ;    private Person person ;//一辆车属于一个人    public Car(String name,double price) &#123;        this.name = name ;        this.price = price ;    &#125;    public void setPerson(Person person) &#123;        this.person = person ;    &#125;    public Person getPerson() &#123;        return this.person ;     &#125;    public String getInfo() &#123;        return &quot;汽车品牌号&quot; + this.name + &quot;、汽车价格:&quot; + this.price ;    &#125;&#125;class Person &#123;    private String name ;    private int age ;    private Car car ;//一个人有一辆车    private Person children [] ;//一个人有多个孩子    public void setChildren (Person children[]) &#123;        this.children = children ;    &#125;    public Person [] getChildren() &#123;        return children ;    &#125;    public Person(String name,int age) &#123;        this.name = name ;        this.age = age ;    &#125;    public void setCar(Car car) &#123;        this.car = car ;    &#125;    public Car getCar() &#123;        return this.car ;    &#125;    public String getInfo() &#123;        return &quot;姓名：&quot; + this.name + &quot;、年龄：&quot; + this.age ;    &#125;&#125;public class Demo &#123;    public static void main(String args[]) &#123;        //声明对象并且设置彼此的关系        Person person = new Person(&quot;Mr.lin&quot;,29) ;        Person childA = new Person(&quot;AA&quot;,10) ;        Person childB = new Person(&quot;BB&quot;,13) ;        childA.setCar(new Car(&quot;X&quot;,100)) ;        childB.setCar(new Car(&quot;XX&quot;,1000)) ;        person.setChildren(new Person [] &#123;childA,childB&#125;) ;        Car car = new Car(&quot;binli&quot;,10) ;        person.setCar(car) ;//一个人有一辆车        car.setPerson(person) ;//一辆车属于一个人        //第二部：根据关系获取数据        System.out.println(person.getCar().getInfo()) ;//代码链        System.out.println(car.getPerson().getInfo()) ;//代码链        for(int i = 0 ; i &lt; person.getChildren().length ; i++) &#123;            System.out.println(&quot;\\t|-&quot; + person.getChildren()[i].getInfo()) ;            System.out.println(&quot;\\t\\t|-&quot; + person.getChildren()[i].getCar().getInfo()) ;        &#125;    &#125;&#125;\n\n数据表与简单Java类映射转换映射转换\n数据实体表设计 = 类的定义\n表中的字段 = 类的成员属性\n表的外键关联 = 引用关联\n表的一行记录 = 类的一个实例化对象\n表的多行记录 = 对象数组\n\n​        对于数据表与简单Java类之间的映射最好的解决步骤：先抛开所有的关联字段不看，写出类的基本组成，而后通过引用配置关联字段的关系\n一对多映射class Item &#123;    private long iid ;    private String title ;    private Subitem subitems [] ;    public Item(long iid ,String title) &#123;        this.title = title ;        this.iid = iid ;    &#125;    public void setSubitems(Subitem subitems[]) &#123;        this.subitems = subitems ;    &#125;    public Subitem [] getSubitems() &#123;        return this.subitems ;    &#125;    public String getInfo() &#123;        return &quot;【分类信息】iid = &quot; + this.iid + &quot;title = &quot; + this.title ;      &#125;&#125;class Subitem &#123;    private long sid ;    private String title ;    private Item item ;    public Subitem(long sid,String title) &#123;        this.sid = sid ;        this.title = title ;    &#125;    public void setItem(Item item) &#123;        this.item = item ;    &#125;    public Item getItem() &#123;        return this.item ;    &#125;    public String getInfo() &#123;        return &quot;【自分类信息】sid = &quot; + this.sid + &quot;title = &quot; + this.title ;    &#125;&#125;public class Demo &#123;    public static void main(String args[]) &#123;        //第一步：根据结构设置对象数据        Item item = new Item(1L,&quot;图书&quot;) ;        Subitem subitems [] = new Subitem [] &#123;            new Subitem(10L,&quot;编程图书&quot;),            new Subitem(10L,&quot;图形图像类图书&quot;)        &#125; ;        item.setSubitems(subitems) ;        for(int i = 0 ; i &lt; subitems.length ; i++) &#123;            //第二部：根据要求获取数据            subitems[i].setItem(item) ;        &#125;        System.out.println(item.getInfo()) ;        for(int i = 0 ; i &lt; item.getSubitems().length ; i++) &#123;            System.out.println(&quot;\\t&quot;+item.getSubitems()[i].getInfo()) ;        &#125;    &#125;&#125;\n\n多对多映射class Member &#123;    private String mid ;    private String name ;    private Product products [] ;//多对多不管中间记录表    public Member(String mid,String name) &#123;        this.mid = mid ;        this.name = name ;    &#125;    public void setProducts(Product products []) &#123;        this.products = products ;    &#125;    public Product [] getProducts() &#123;        return this.products ;    &#125;    public String getInfo() &#123;        return &quot;【用户信息】mid = &quot; + this.mid + &quot;      name = &quot; + this.name ;    &#125;&#125;class Product &#123;    private long pid ;    private String title ;    private double price ;    private Member members [] ;    public Product(long pid,String title,double price) &#123;        this.pid = pid ;        this.title = title ;        this.price = price ;    &#125;    public void setMembers (Member members []) &#123;        this.members = members ;    &#125;    public Member [] getMembers () &#123;        return this.members ;    &#125;    public String getInfo() &#123;        return &quot;【商品信息】pid = &quot; + this.pid +&quot;       title = &quot; + this.title + &quot;      price = &quot; + this.price ;    &#125;&#125;public class Demo &#123;    public static void main(String args[]) &#123;        //设置结构设置对象数据        Member memA = new Member(&quot;mldn&quot;,&quot;Davi&quot;) ;        Member memB = new Member(&quot;mlnjava&quot;,&quot;Michael&quot;) ;                //注意此处1L、2L、3L        Product proA = new Product(1L,&quot;Java开发图书&quot;,79.8) ;//此处1L表示1是长整型        Product proB = new Product(2L,&quot;耳机&quot;,1499) ;//如果为1f则为float型        Product proC = new Product(3L,&quot;小米手机&quot;,1999) ;//1L就是1        memA.setProducts(new Product[] &#123;proA,proB,proC&#125;) ;        memB.setProducts(new Product[] &#123;proA&#125;) ;        proA.setMembers(new Member[] &#123;memA,memB&#125;) ;        proB.setMembers(new Member[] &#123;memA&#125;) ;        proC.setMembers(new Member[] &#123;memA&#125;) ;        //第二部：根据要求获取数据        System.out.println(&quot;--------根据用户查看浏览商品信息---------&quot;) ;        System.out.println(memA.getInfo()) ;        for(int i = 0 ; i &lt; memA.getProducts().length ; i++) &#123;            System.out.println(&quot;\\t&quot; + memA.getProducts()[i].getInfo()) ;        &#125;        System.out.println(&quot;--------根据商品查看浏览用户信息---------&quot;) ;         System.out.println(proA.getInfo()) ;        for(int i = 0 ; i &lt; proA.getMembers().length ; i++) &#123;            System.out.println(&quot;\\t&quot; + proA.getMembers()[i].getInfo()) ;        &#125;    &#125;&#125;\n\n复杂多对多映射根据要求实现如下功能：\n\n可以根据一个用户找到该用户对应的所有角色，以及每一个角色对应的所有权限信息；\n可以根据一个角色找到该角色下的所有权限，以及拥有此角色的全部用户信息；\n可以根据一个权限找到具备此权限所有用户信息\n\nclass Member &#123;    private String mid ;    private String name ;    private Role roles [] ;    public Member(String mid,String name) &#123;        this.mid = mid ;        this.name = name ;    &#125;    public void setRoles(Role roles[]) &#123;        this.roles = roles ;    &#125;    public Role [] getRoles() &#123;        return this.roles ;    &#125;    public String getInfo() &#123;        return &quot;【用户信息】id = &quot; + this.mid + &quot;\t\tname = &quot; + this.name ;    &#125;&#125;class Role &#123;    private long rid ;    private String title ;    private Privilege privileges [] ;    private Member members [] ;    public Role(long rid,String title) &#123;        this.rid = rid ;        this.title = title ;    &#125;    public void setPrivileges(Privilege privileges[]) &#123;        this.privileges = privileges ;     &#125;    public Privilege [] getPrivileges() &#123;        return this.privileges ;    &#125;    public void setMembers(Member members[]) &#123;        this.members = members ;    &#125;    public Member [] getMembers() &#123;        return this.members ;    &#125;    public String getInfo() &#123;        return &quot;【角色信息】id = &quot; + this.rid + &quot;\t\ttitle = &quot; + this.title ;    &#125;&#125;class Privilege &#123;    private long pid ;    private String title ;    private Role role ;    private Member members [] ;    public Privilege(long pid,String title) &#123;        this.pid = pid ;        this.title = title ;    &#125;    public void setRole(Role role)&#123;        this.role = role ;    &#125;    public Role getRole()&#123;        return this.role ;    &#125;    public void setMembers(Member members[]) &#123;        this.members = members ;    &#125;    public Member [] getMembers() &#123;        return this.members ;    &#125;    public String getInfo() &#123;        return &quot;【权限信息】id = &quot; + this.pid + &quot;\t\ttitle = &quot; + this.title ;    &#125;&#125;public class Demo &#123;    public static void main(String args[]) &#123;        Member memA = new Member(&quot;a&quot;,&quot;Bob&quot;) ;        Member memB = new Member(&quot;b&quot;,&quot;kang&quot;) ;        Role roleA = new Role(1L,&quot;系统配置&quot;) ;        Role roleB = new Role(2L,&quot;备份管理&quot;) ;        Role roleC = new Role(3L,&quot;人事管理&quot;) ;        Privilege priA = new Privilege (1000L,&quot;系统初始化&quot;) ;        Privilege priB = new Privilege (1001L,&quot;系统系统还原&quot;) ;        Privilege priC = new Privilege (1002L,&quot;系统环境修改&quot;) ;          Privilege priD = new Privilege (2000L,&quot;备份员工数据&quot;) ;        Privilege priE = new Privilege (2001L,&quot;备份部门数据&quot;) ;        Privilege priF = new Privilege (2002L,&quot;备份公文数据&quot;) ;        Privilege priG = new Privilege (3000L,&quot;增加员工&quot;) ;\t\tPrivilege priH = new Privilege (3001L,&quot;编辑员工&quot;) ;        Privilege priI = new Privilege (3002L,&quot;浏览员工&quot;) ;\t\tPrivilege priJ = new Privilege (3003L,&quot;员工离职&quot;) ;        roleA.setMembers(new Member[] &#123;memA,memB&#125;) ;        roleB.setMembers(new Member[] &#123;memA,memB&#125;) ;        roleC.setMembers(new Member[] &#123;memB&#125;) ;        //增加角色与权限对应关系\t\troleA.setPrivileges(new Privilege[] &#123;priA,priB,priC&#125;) ;        roleB.setPrivileges(new Privilege[] &#123;priD,priE,priF&#125;) ;        roleC.setPrivileges(new Privilege[] &#123;priG,priH,priI,priJ&#125;) ;        //增加权限与角色对应        priA.setRole(roleA) ;        priB.setRole(roleA) ;        priC.setRole(roleA) ;        priD.setRole(roleB) ;        priF.setRole(roleB) ;        priG.setRole(roleB) ;        priH.setRole(roleC) ;        priI.setRole(roleC) ;        priJ.setRole(roleC) ;        //增加用户与角色对应        memA.setRoles(new Role[] &#123;roleA,roleB&#125;) ;        memB.setRoles(new Role[] &#123;roleA,roleB,roleC&#125;) ;        roleA.setMembers(new Member[] &#123;memA,memB&#125;) ;        roleB.setMembers(new Member[] &#123;memA,memB&#125;) ;        roleC.setMembers(new Member[] &#123;memB&#125;) ;        System.out.println(&quot;---------通过用户查找信息----------&quot;) ;        System.out.println(memB.getInfo()) ;        for(int x = 0 ; x &lt; memB.getRoles().length ; x++)&#123;            System.out.println(&quot;\\t&quot; + memB.getRoles()[x].getInfo()) ;            for(int y = 0 ; y &lt; memB.getRoles()[x].getPrivileges().length ; y++)&#123;                System.out.println(&quot;\\t\\t&quot; + memB.getRoles()[x].getPrivileges()[y].getInfo()) ;            &#125;        &#125;        System.out.println(&quot;---------通过角色查找信息----------&quot;) ;        System.out.println(roleB.getInfo()) ;        System.out.println(&quot;\\t 浏览此角色下的所有权限信息:&quot;) ;        for(int x = 0 ; x &lt; roleB.getPrivileges().length ; x++)&#123;            System.out.println(&quot;\\t&quot; + roleB.getPrivileges()[x].getInfo()) ;        &#125;        System.out.println(&quot;\\t 浏览此角色下的所有用户信息:&quot;) ;        for(int x = 0 ; x &lt; roleB.getMembers().length ; x++) &#123;            System.out.println(&quot;\\t &quot;+ roleB.getMembers()[x].getInfo()) ;        &#125;        System.out.println(&quot;---------通过权限查找信息----------&quot;) ;        System.out.println(priA.getInfo()) ;        for(int x = 0 ;x &lt; priA.getRole().getMembers().length ; x++)&#123;            System.out.println(&quot;\\t&quot; + priA.getRole().getMembers()[x].getInfo()) ;        &#125;    &#125;&#125;\n\nString类特点分析String类简介字符串严格意义上说不能算是基本数据类型，也就是说没有任何一门语言会提供有字符串这种数据类型，而Java里面为了方便开发者进行项目的编写，利用JVM的支持制造了一种可以简单使用的String类。\nString本身包装的是一个数组，并且其有两种对象的实例化形式\n\n直接赋值\n构造方法实例化\n\npublic class Demo &#123;    public static void main(String[] args) &#123;        String str1 = &quot;BearKouber.github.io&quot; ;//直接赋值        System.out.println(str1) ;        String str2 = new String (&quot;BearKouber.github.io&quot;) ;//构造方法实例化\t\tSystem.out.println(str2) ;    &#125;&#125;\n\n\n\n\nJDK1.8之前String保存的是字符数组\nJDK1.9以后String保存的是字节数组\n\n\n\nprivate final char value[];\nprivate final byte[] value\n\n\n所谓的字符串就是对数组的一种特殊包装应用；\n注意：因为包装的是数组，所以字符串里面的内容是肯定无法改变的\n字符串比较String可以像基本数据类型一样进行判断(==)，但是判断结果不准确\npublic class Demo &#123;    public static void main(String[] args) &#123;        String strA = &quot;kouber&quot; ;        String strB = new String (&quot;kouber&quot;) ;        System.out.println(strA == strB) ;//false    &#125;&#125;\n\n想要获得准确判断结果可以使用String类中提供的一个比较方法：\npublic boolean equals(String str);//有变形\n\npublic class Demo &#123;    public static void main(String[] args) &#123;        String strA = &quot;kouber&quot; ;        String strB = new String (&quot;kouber&quot;) ;        System.out.println(strA.equals(strB)) ;//true    &#125;&#125;\n\n比较String与equals()的区别 \n\n==比较的是数值比较，如果用于对象比较上比较的是两个内存的地址数值，而new是会分配新的地址空间，因此使用”==”就会出现错误判断结果；\nequals() 是类所提供的一个比较方法，可以直接进行字符串内容的判断\n\n字符串常量是String类的匿名对象程序之中不会提供有字符串这样的基本数据类型，提供的只是String类，所以任何使用&quot;定义的字符串常量实际上描述的都是一个String类的匿名对象。\npublic class Demo &#123;    public static void main(String[] args) &#123;        String str = &quot;kouber&quot; ;        System.out.println(&quot;kouber&quot;.equals(str)) ;//true    &#125;&#125;\n\n所谓的String类对象的直接赋值直接描述的是，将一个匿名对象设置一个具体的引用名字。\n观察匿名对象的存在：\npublic class Demo &#123;    public static void main(String[] args) &#123;        String str = &quot;kouber&quot; ;        System.out.println(&quot;kouber&quot;.equals(str)) ; //true    &#125;&#125;\n\n可以看出kouber竟可以使用equals()方法实现对象相等的判断，所以可以得出结论：程序中的确没有字符串常量，有的只是String类的匿名对象。(什么？我看不懂啊歪！！！)\n关于对象相等判断的小技巧:\n将字符串常量写在前面\n\n接收用户输入数据的字符串调用方法\n\n当输入不为空时\n\npublic class Demo &#123;    public static void main(String[] args) &#123;        String str = &quot;kouber&quot; ; //str为用户输入的内容        System.out.println(str.equals(&quot;kouber&quot;)) ; //true    &#125;&#125;\n\n\n\n\n当输入为空时\n\npublic class Demo &#123;    public static void main(String[] args) &#123;        String str = null ; //str为用户输入的内容        System.out.println(str.equals(&quot;null&quot;)) ; //报错：Exception in thread &quot;main&quot; java.lang.NullPointerException    &#125;&#125;\n将字符串对象写在前面\n\n\npublic class Demo &#123;    public static void main(String[] args) &#123;        String str = null ; //str为用户输入的内容        System.out.println(&quot;kouber&quot;.equals(str)) ; //false    &#125;&#125;\n\nequals()方法里面提供有一个可以回避null的判断，如果将字符串常量写在前面，那么调用equals()方法的时候永远都不可能出现NullPointerException,字符串是一个匿名对象，匿名对象一定是开辟好堆内存空间的对象。\nString类对象两种实例化方式比较直接赋值实例化在程序之中只需要把字符串赋值给String对象就可以实现对象的实例化处理\n这种情况下肯定只会开辟出一块堆内存空间\npublic class Demo &#123;    public static void main(String[] args) &#123;        String str = &quot;kouber&quot; ;     &#125;&#125;\n\n除了这种内存模式之外，利用直接赋值实例化String的形式还可以实现同一个字符串对象数据的共享操作。\n观察String直接赋值时的数据共享\npublic class Demo &#123;    public static void main(String[] args) &#123;        String strA = &quot;kouber&quot; ;        String strB = &quot;kouber&quot; ;        System.out.println(strA == strB) ;//“==”为地址判断    &#125;//true&#125;\n\n结论：这两个对象所指的堆内存空间是同一个\n即在两个String变量的值相等时\n占两个堆内存空间，一个栈内存空间，strA和strB所指向的地址相同\n\n\n\n堆内存\n栈内存\n\n\n\nstrA\nkouber\n\n\nstrB\n\n\n\n为什么不是在堆空间中开辟两个”kouber“对象而是让strA和strB指向同一个对象呢？\n因为在JVM的共享设计模式 中\nJVM的底层实现实际上在堆中存在一个对象池（常量池，不一定只保存String对象,池就是一个在堆内存中的数组，），当使用直接赋值方式定义String类对象，那么JVM会将此字符串对象使用的匿名对象就是如”kouber“字符串入池保存。如果后面还有其他String对象采用同样方式且设置同样内容时，将不会开辟新的堆空间，而是继续使用相同的空间\n构造方法实例化会开辟两块堆空间，一块在常量池中存储”kouber“字符串常量另一块在堆中存储这个对象。\n而str指向的是对象的地址而不是常量池中”kouber“的地址\npublic class Demo &#123;    public static void main(String[] args) &#123;        String str = new String(&quot;kouber&quot;) ;    &#125;&#125;\n\n这样就会造成一块堆内存空间的浪费(常量池中)\n如果常量池中已存在要使用构造方法定义的字符串，那么只会开辟一个堆内存空间来储存对象\n即下面一共开辟了两个堆内存空间\n一个常量池中的空间储存”kouber“字符串，和另一个堆内存空间储存这个对象。\npublic class Demo &#123;    public static void main(String[] args) &#123;        String strA = &quot;kouber&quot; ;        String strB = new String(&quot;kouber&quot;) ;        System.out.println(strA == strB) ;//false    &#125;&#125;\n\n\n\n让该对象入池的方法(String类的intern方法)\npublic class Demo &#123;    public static void main(String[] args) &#123;        String strA = &quot;kouber&quot; ;        String strB = new String(&quot;kouber&quot;).intern() ;        System.out.println(strA == strB) ;//true    &#125;&#125;\n\n\n\n总结一下两种实例化方法的区别：\n直接赋值方式：只会开辟一块堆内存空间，并且自动保存在常量池中，以供我们下次重复使用。(此处重复使用我感觉就是类似C语言里面的数组的压缩储存)\n构造方法：会开辟两块堆内存空间，其中在常量池的会成为垃圾空间，不会自动入池，不会实现对象重用，可以使用intern()方法手工入池。\n看不懂就点我\n点我更详细\n\nString对象常量池实现数据的共享处理。\n以String对象池为例，里面的内容主要就是为了重用，而重用就是共享设计。\n在Java之中的对象(常量)池可以分为两种\n\n静态常量池：指的是程序(*.class)在加载时候会自动将此程序之中保存全部信息(字符串、普通常量、类、方法)全部进行分配提供的池子。\n运行时常量池：指的是当一个程序(*.class)加载只后，里面可能有一些变量需要用户输入后接收，这个时候提供给可变变量和其他可变数据的的池子。\n\nstrB储存在静态常量池中\npublic class Demo &#123;    public static void main(String[] args) &#123;        String strA = &quot;kouber&quot; ;        String strB = &quot;kou&quot; + &quot;ber&quot; ;        //String strB = &quot;kouber&quot; ; 上面代码跟这行效果一样        System.out.println(strA == strB) ;//true    &#125;&#125;\n\n\n显然strA和StrB指向的是同一地址，即静态常量池中的“kouber”的地址\n\n上述代码中所给出的内容全部都是静态常量数据(字符串的常量都是匿名对象)，所以程序开发中会帮设计者处理好相应的连接\nstrB储存在运行时常量池中\npublic class Demo &#123;    public static void main(String[] args) &#123;        String strK = &quot;kou&quot; ;        String strA = &quot;kouber&quot; ;        String strB = strK + &quot;ber&quot; ;        String strC = &quot;kou&quot;+&quot;ber&quot; ;        System.out.println(&quot;AB  &quot;+ (strA == strB)) ;//false        System.out.println(&quot;AC  &quot;+ (strA == strC)) ;//true        System.out.println(&quot;BC  &quot;+ (strB == strC)) ;//false    &#125;&#125;\n\n程序加载时候不确定strK是什么内容。在字符串进行连接的时候，strK是一个变量，变量的内容是可以修改的，所以程序不认为strB的结果就是最终的结果\n\n上述表达过于晦涩难懂，简单来说就是strB在动态常量池中，strA和strC在静态在常量池中\n\n结论：遇见变量数据时，最终比较变量时需要使用equals()\n字符串修改分析String定义之后无法修改\npublic class Demo &#123;    public static void main(String[] args) &#123;        String str = &quot;bear&quot; ;        str += &quot;kou&quot; ;        str += &quot;ber&quot; ;        System.out.println(str) ;//bearkouber    &#125;&#125;\n\n为什么上面代码看似是修改了String变量\n\n\n\n栈内存\n堆内存\n\n\n\nstr\nbear\n\n\n\nkou\n\n\n\nbearkou\n\n\n\nber\n\n\n\nbearkouber\n\n\n对str内容的修实际上是str指针指向的变化：\n\n指向bear\n指向bearkou\n指向bearkouber\n\n这样做造成的结果为：\n堆内存bear、kou、bearkou、ber将成为垃圾内存空间，string对象的指向修改了2次。\n在开发中频繁对String类内容进行修改会使程序的性能变得很差\n主方法组成分析public static void main(String[] args)\n\n\npublic:描述 的是一种访问权限，主方法是一切的开始点，开始点一定是公共的；\nstatic:程序的执行是通过类名称完成的，所以此方法是由类直接调用;\nvoid:主方法是一切的起点，起点一旦开始就没有返回的可能；\nmain:是一个系统定义好的方法名称；\nString[] args:字符串的数组，可以实现程序启动参数的接收\n\n在程序执行时候可以设置参数，每一个参数之间使用空格分割\npublic class Demo &#123;    public static void main(String[] args) &#123;        for(String arg:args)&#123;            System.out.println(arg) ;        &#125;    &#125;&#125;\n\n&gt;javac Demo.java&gt;java Demo first secondfirstsecond\n\n注意：如果参数含空格，则必须使用“””包装\npublic class Demo &#123;    public static void main(String[] args) &#123;        for(String arg:args)&#123;            System.out.println(arg) ;        &#125;    &#125;&#125;\n\n&gt;javac Demo.java&gt;java Demo&quot;Hello World!&quot;Hello World!\n\n\n\nSting类常用方法JavaDoc文档就是这个\n字符串与字符获取字符串其中一个字符(charAt)public class Demo &#123;    public static void main(String[] args) &#123;        String str = &quot;kouber&quot; ;        char c = str.charAt(1) ;        System.out.println(c) ;//o            &#125;&#125;\n\n字符串与字符数组的相互转换public class Demo &#123;    public static void main(String[] args) &#123;        String str = &quot;kouber&quot; ;        char [] name = str.toCharArray() ;//将字符串转换为字符数组        String newStr = new String(str) ;//将字符数组转换为字符串        for(int i = 0 ;i &lt; name.length ; i++) &#123;            System.out.print(name[i]) ;//kouber        &#125;    &#125;&#125;\n\n字符串与字节字节长度：-128~127\n\n\n\n方法\n作用\n\n\n\npublic String (byte [] bytes)\n将全部字符数组变为字符串\n\n\npublic String(byte [] bytes,int offset,int length)\n将部分字符数组变为字符串\n\n\npublic byte [] getBytes()\n将字符串转为字节数组\n\n\npublic byte [] getBytes(StringcharsetName) throwsUnsupportedEncodingException\n编码转换\n\n\n分别用char和byte将String类型的kouber全部变为大写并输出charpublic class Demo &#123;\tpublic static void main(String[] args) &#123;\t\tString str = &quot;kouber&quot; ;\t\tchar [] name = str.toCharArray() ;//字符串转字符数组\t\tfor(int i = 0 ; i &lt; name.length ; i++) &#123;            name[i] -= 32 ;        &#125;        System.out.println(new String(name)) ;//KOUBER        System.out.println(new String(name,0,3)) ;//KOU\t&#125;&#125;\n\nbytepublic class Demo &#123;    public static void main(String[] args) &#123;        String str = &quot;kouber&quot; ;        byte [] name = str.getBytes() ;//将字符串转字节数组        for(int i = 0 ; i &lt; name.length ; i++) &#123;            name[i] -= 32 ;        &#125;        System.out.println(new String(name)) ;//KOUBER        System.out.println(new String(name,0,3)) ;//KOU    &#125;&#125;\n\n字符串比较忽略字母大小写进行比较是否相等(equalsIgnoreCase())public class Demo &#123;\tpublic static void main(String[] args) &#123;\t\tString strA = &quot;kou&quot; ;\t\tString strB = &quot;KOU&quot; ;\t\tSystem.out.println(strA.equals(strB)) ;//false\t\tSystem.out.println(strB.equalsIgnoreCase(strB)) ;//true\t&#125;&#125;\n\n返回两个字符串的差值(strA-strB)区分大小写public class Demo &#123;\tpublic static void main(String[] args) &#123;\t\tString strA = &quot;AB&quot; ;\t\tString strB = &quot;AA&quot; ;\t\tSystem.out.println(strA.compareTo(strB)) ;//1\t&#125;&#125;\n\n不区分大小写public class Demo &#123;\tpublic static void main(String[] args) &#123;\t\tString strA = &quot;AB&quot; ;\t\tString strB = &quot;Ab&quot; ;\t\tSystem.out.println(strA.compareTo(strB)) ;//32        System.out.println(strA.compareToIgnoreCase(strB)) ;//0\t&#125;&#125;\n\n字符串查找containspublic class Demo &#123;\tpublic static void main(String[] args) &#123;\t\tString str = &quot;BearKouber&quot; ;\t\tSystem.out.println(str.contains(&quot;Kou&quot;)) ;//true\t\tSystem.out.println(str.contains(&quot;kou&quot;)) ;//false\t&#125;&#125;\n\nindexOf查找方式：前→后\n返回指定字符在字符串中第一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。\npublic class Demo &#123;\tpublic static void main(String[] args) &#123;\t\tString str = &quot;BearKouber&quot; ;\t\tSystem.out.println(str.indexOf(&quot;Kou&quot;)) ;//4\t\tSystem.out.println(str.indexOf(&quot;kou&quot;)) ;//-1\t&#125;&#125;\n\nlastIndexOf查找方式：后→前\npublic class Demo &#123;\tpublic static void main(String[] args) &#123;\t\tString str = &quot;BearKouber&quot; ;\t\tSystem.out.println(str.lastIndexOf(&quot;r&quot;)) ;//9 有两个r但是输出的是后面的r的位置        System.out.println(str.lastIndexOf(&quot;r&quot;,8)) ;//3 此处8是指从第八个位置开始查找\t&#125;&#125;\n\nstartsWith和endsWith用于检测字符串是否以指定的前缀开始。\npublic class Demo &#123;\tpublic static void main(String[] args) &#123;\t\tString str = &quot;@@BearKouber##&quot; ;\t\tSystem.out.println(str.startsWith(&quot;@@&quot;)) ;//true        System.out.println(str.startsWith(&quot;Bear&quot;,2)) ;//true        System.out.println(str.endsWith(&quot;##&quot;)) ;//true        System.out.println(str.endsWith(&quot;ber&quot;,2)) ;//只有startsWith有从第几个位置开始查找而endsWith没有这个方法，因此此行会报错\t&#125;&#125;\n\n字符串替换replace()public class Demo &#123;    public static void main(String[] args) &#123;        String str = &quot;helloworld &quot; ;        System.out.println(str.replaceAll(&quot;l&quot;,&quot;X&quot;)) ;//全部替换        System.out.println(str.replaceFirst(&quot;l&quot;,&quot;X&quot;)) ;//第一位替换    &#125;&#125;//heXXoworXd //heXloworld\n\n字符串拆分split()public class Demo &#123;    public static void main(String[] args) &#123;        String str = &quot;hello world hello world&quot; ;        String [] result = str.split(&quot; &quot;) ;//按空格拆分        for(int i = 0 ; i &lt; result.length ; i++) &#123;            System.out.println(result[i]) ;        &#125;                &#125;&#125;// hello// world// hello// world\n\npublic class Demo &#123;    public static void main(String[] args) &#123;        String str = &quot;hello world hello world&quot; ;        String [] result = str.split(&quot; &quot;,2) ;//按空格分两部分拆分        for(int i = 0 ; i &lt; result.length ; i++) &#123;            System.out.println(result[i]) ;        &#125;                &#125;&#125;//hello//world hello world\n\n拆不开的情况public class Demo &#123;    public static void main(String[] args) &#123;        String str = &quot;127.0.0.1&quot; ;        String [] result = str.split(&quot;.&quot;) ;        for(int i = 0 ; i &lt; result.length ; i++) &#123;            System.out.println(result[i]) ;        &#125;                &#125;&#125;//输出结果为空\n\n解决方法：加双斜线\\\\public class Demo &#123;    public static void main(String[] args) &#123;        String str = &quot;127.0.0.1&quot; ;        String [] result = str.split(&quot;\\\\.&quot;) ;        for(int i = 0 ; i &lt; result.length ; i++) &#123;            System.out.println(result[i]) ;        &#125;                &#125;&#125;// 127// 0// 0// 1\n\n字符串的截取substring()public class Demo &#123;    public static void main(String[] args) &#123;        String str = &quot;BearKouber&quot; ;        System.out.println(str.substring(4)) ;//Kouber        System.out.println(str.substring(4,7)) ;//Kou    &#125;&#125;\n\n\n\npublic class Demo &#123;    public static void main(String[] args) &#123;        String str = &quot;K30-photo-Kouber.jpg&quot; ;        int beginIndex = str.indexOf(&quot;-&quot;,str.indexOf(&quot;photo&quot;))+1 ;        int endIndex = str.lastIndexOf(&quot;.&quot;) ;        System.out.println(str.substring(beginIndex,endIndex)) ;    &#125;&#125;//Kouber\n\n格式化字符串format()可以通过占位符对数据进行输出\n常用占位符：字符串(%s),字符(%c),整数(%d),小数(%f) \npublic class Demo &#123;    public static void main(String[] args) &#123;        String name = &quot;Kouber&quot; ;        int age = 19 ;        double score = 60.654321 ;        String str = String.format(&quot;name:%s,age:%d,score:%5.1f&quot;,name,age,score) ;        System.out.println(str) ;    &#125;&#125;//name:Kouber,age:19,score: 60.7\n\n字符串连接concat()\n此处可以看出动态常量池不是共享设计结构，每个字符串单独存储\n\npublic class Demo &#123;    public static void main(String[] args) &#123;        String strA = &quot;BearKouber&quot; ;        String strB = &quot;Bear&quot;.concat(&quot;Kou&quot;).concat(&quot;ber&quot;) ;        String strC = &quot;Bear&quot; ;        String strD = &quot;Kouber&quot; ;        String strE = strC + &quot;Kouber&quot; ;        String strF = strC + strB ;        System.out.println(&quot;B &quot; +strB) ;//BearKouber        System.out.println(&quot;E &quot; +strD) ;//BearKouber        System.out.println(&quot;F &quot; +strF) ;//BearKouber        System.out.println(&quot;AB &quot; +(strA == strB)) ;//false        System.out.println(&quot;BE &quot; +(strB == strD)) ;//false        System.out.println(&quot;BF &quot; +(strB == strF)) ;//false        System.out.println(&quot;EF &quot; +(strE == strF)) ;//false    &#125;&#125;\n\n判断字符串是否为空此空非彼空\n在字符串定义时候的&quot;&quot;和null不是一个概念，前者有实例化对象，后者没有实例化对象。\nisImpty是在有实例化对象时候才能进行调用的方法\npublic class Demo &#123;    public static void main(String[] args) &#123;        String str = &quot;&quot; ;        System.out.println(str.isEmpty()) ;//true       \tSystem.out.println(&quot;kou&quot;.isEmpty()) ;//false    &#125;&#125;\n\n返回字符串长度length(),消除字符串两侧空格trim()public class Demo &#123;    public static void main(String[] args) &#123;        String str = &quot;   Hello World   &quot; ;        System.out.print(str) ;        System.out.println(str.length()) ;//17        String trimStr = str.trim() ;        System.out.print(trimStr) ;        System.out.println(trimStr.length()) ;//11    &#125;&#125;//    Hello World   17// Hello World11\n\n数组length是一个属性是没有括号的，字符串里的length是有括号的方法\npublic class Demo &#123;    public static void main(String[] args) &#123;        int [] a = new int [] &#123;1,2,3,4,5,6,7&#125; ;        System.out.println(a.length) ;//7    &#125;&#125;\n\n大小写转换toUpperCase()&amp;toLowerCase()public class Demo &#123;    public static void main(String[] args) &#123;        String str = &quot;Hello World !!!&quot; ;        System.out.println(str.toUpperCase()) ;        System.out.println(str.toLowerCase()) ;    &#125;&#125;// HELLO WORLD !!!// hello world !!!\n\n自定义一个实现首字母大写的方法class StringUtil &#123;    public static String initcap(String str) &#123;        if(str == null || &quot;&quot;.equals(str)) &#123;            return str ;        &#125;        if(str.length() == 1) &#123;            return str.toUpperCase() ;        &#125;        return str.substring(0,1).toUpperCase() + str.substring(1) ;    &#125;&#125;public class Demo &#123;    public static void main(String[] args)&#123;        System.out.println(StringUtil.initcap(&quot;hello&quot;)) ;        System.out.println(StringUtil.initcap(&quot;m&quot;)) ;    &#125;&#125;// Hello// M\n\n继承的定义与使用继承的主要特点：可以扩充已有类的功能。\n好的代码：结构性合理、适合于维护，可用性很高。\n为什么会出现继承？\n当我们开发时候用之前学到的内容进行开发会不可避免的出现一些重复代码，就比如说建立一个人的类和一个学生的类，学生的类中是包含了人的类的所有属性，此时会有重复代码出现，于是可以把人的类当做学生的类的一部分则会省去重复的这段代码。\n继承的实现需依靠extends关键字来完成\nclass 子类 extends 父类 &#123;&#125;\n\n子类——派生类，父类——超类(SuperClass)\nclass Person &#123;    private String name ;    private int age ;    //注意此处没有构造方法，默认为无参构造    public String getName() &#123;        return this.name ;    &#125;    public int getAge() &#123;        return this.age ;    &#125;    public void setName(String name) &#123;        this.name = name ;    &#125;    public void setAge(int age) &#123;        this.age = age ;    &#125;    public String getInfo() &#123;        return &quot;name:&quot; + this.name + &quot;,age:&quot; + this.age ;    &#125;&#125;class Student extends Person &#123;&#125;class Demo &#123;    public static void main(String[] args) &#123;        //此处子类初始化，调用了无参构造        Student stu = new Student() ;        stu.setName(&quot;kouber&quot;) ;        stu.setAge(18) ;        System.out.println(stu.getInfo()) ;    &#125;&#125;\n\nextends报错class Person &#123;    private String name ;    private int age ;    //注意此处是有参构造    public Person(String name,int age) &#123;        this.name = name ;        this.age = age ;    &#125;    public String getName() &#123;        return this.name ;    &#125;    public int getAge() &#123;        return this.age ;    &#125;    public void setName(String name) &#123;        this.name = name ;    &#125;    public void setAge(int age) &#123;        this.age = age ;    &#125;    public String getInfo() &#123;        return &quot;name:&quot; + this.name + &quot;,age:&quot; + this.age ;    &#125;&#125;class Student extends Person &#123;        //此处为空的话是默认调用父类无参构造，但是父类的有参构造覆盖了无参构造,此处因父类没有无参构造而报错&#125;class Demo &#123;    public static void main(String[] args) &#123;        Student stu = new Student() ;        stu.setName(&quot;kouber&quot;) ;//父类定义        stu.setAge(18) ;//父类定义        System.out.println(stu.getInfo()) ;    &#125;&#125;// Demo.java:24: 错误: 无法将类 Person中的构造器 Person应用到给定类型;// class Student extends Person &#123;&#125;// ^//   需要: String,int//   找到: 没有参数//   原因: 实际参数列表和形式参数列表长度不同\n\n报错原因子类初始化的时候，如果不指定调用父类的某个构造，则需要调用父类的无参构造。你父类的构造是有参构造。会把默认的无参构造覆盖掉。所以编译会报错。\n解决方法1.在父类中加一个无参构造class Person &#123;    private String name ;    private int age ;    public Person()&#123;&#125;    public Person(String name,int age) &#123;        this.name = name ;        this.age = age ;    &#125;    public String getName() &#123;        return this.name ;    &#125;    public int getAge() &#123;        return this.age ;    &#125;    public void setName(String name) &#123;        this.name = name ;    &#125;    public void setAge(int age) &#123;        this.age = age ;    &#125;    public String getInfo() &#123;        return &quot;name:&quot; + this.name + &quot;,age:&quot; + this.age ;    &#125;&#125;class Student extends Person &#123;    private String school ;    public void setSchool(String school) &#123;        this.school = school ;    &#125;    public String getSchool() &#123;        return this.school ;    &#125;&#125;class Demo &#123;    public static void main(String[] args) &#123;        Student stu = new Student() ;        stu.setName(&quot;kouber&quot;) ;        stu.setAge(18) ;        stu.setSchool(&quot;aygxy&quot;) ;        System.out.print(stu.getInfo()) ;//name:kouber,age:18        System.out.println(&quot;,school:&quot; + stu.getSchool()) ;    &#125;&#125;\n\n2.子类中用super显式指定调用哪个父类构造class Person &#123;    private String name ;    private int age ;    public Person(String name,int age) &#123;        this.name = name ;        this.age = age ;    &#125;&#125;class Student extends Person &#123;    private String school ;    public Student(String name,int age,String School) &#123;        super(name,age) ;//明确调父类构造，此语句是在构造方法里面并处于第一行的位置        this.school = school ;    &#125;&#125;class Demo &#123;    public static void main(String[] args) &#123;        new Student(&quot;kouber&quot;,18,&quot;aygxy&quot;) ;//实例化子类对象    &#125;&#125;\n\n子类对象实例化流程实例化子类对象的同时一定会实例化父类对象，相当于子类构造方法里面隐含一个super()\n其实此处实例化父类很好理解，子类继承了父类的属性，那这些继承的属性要有空间存放，而开辟这片空间的其实是父类 ，因此每次实例化子类时，父类也会进行实例化。\nclass Person &#123;    public Person() &#123;        System.out.println(&quot;A new Person parent class instantiates the object is created&quot;) ;    &#125;&#125;class Student extends Person &#123;    public Student() &#123;        super() ; // 此语句存在与否效果一样        System.out.println(&quot;A new Student class instantiates the object is created&quot;) ;    &#125;&#125;public class Demo &#123;    public static void main(String[] args) &#123;        new Student() ;//实例化子类对象    &#125;&#125;// A new Person parent class instantiates the object// A new Student class instantiates the object\n\nsuper()表示的就是子类构造调用父类构造的语句，该语句只允许放在子类构造方法的首行。默认情况下子类只会调用父类的无参构造方法，因此写不写super() 区别不大，但如果父类里面没有提供无参构造，那么必须利用super()明确调用有参构造。详细代码请看上面extends报错第二个解决方法\nsuper与this都可以调用构造方法，super是子类调用父类的构造，而this是调用本类构造，两者的共同特点是都需要放在构造方法的首行，正因如此两个语句是不能同时存在的。\n继承的相关限制Java之中不允许多重继承，只允许多层继承\n多重继承(错误示例)目的是为了同时继承多个类的方法\nclass A &#123;&#125;class B &#123;&#125;class C extends A,B &#123;&#125; //这必定报错public class Demo &#123;    public static void main(String args[])&#123;            &#125;&#125;\n\n使用多层继承实现多重继承的目的多层继承就是套娃继承\nclass A &#123;&#125;class B &#123;&#125;class B extends A &#123;&#125;class C extends B &#123;&#125;public class Demo &#123;    public static void main(String args[])&#123;            &#125;&#125;\n\n注意：套娃虽好，但最好不要超过三层\n子类会继承父类所有操作但是对于私有操作属于隐式继承，而所有的非私有操作属于显式继承\n看不明白没关系，看下面代码没毛病就行\nclass Person &#123;    private String name ;    public String getName() &#123;        return this.name ;    &#125;    public void setName(String name) &#123;        this.name = name ;    &#125;&#125;class Student extends Person &#123;    public void fun()&#123;\t\t//System.out.println(name) ; //子类不能直接访问父类private属性            //报错信息：错误: name 在 Person 中是 private 访问控制        System.out.println(getName()) ;   &#125;&#125;class Demo &#123;    public static void main(String[] args) &#123;        Student stu = new Student() ;        stu.setName(&quot;kouber&quot;) ;        stu.fun() ;    &#125;&#125;\n\n"},{"title":"XML基础","url":"/2022/08/01/XML%E5%9F%BA%E7%A1%80/","content":"XML简介内容介绍\nxml是什么\n2.特点：标记性语言，可拓展\n3.xml用途\n\n1.xml是什么•     XML是指可扩展标记语言(Xtensible Markup Language),它是一种标记语言，很类似HTML。它被设计的宗旨是传输数据，而非显示数据。\n•     XML标签没有被预定义，需要用户自行定义标签。\n•     XML技术是W3C组织(World Wide Web Consortium万维网联盟)发布的，目前遵循的是W3C组织于2000年发布的XML1.0规范。\n•     XML被广泛认为是继Java之后在Internet上最激动人心的新技术。\n2.特点extensible Markup Language:可扩展标记型语言\n•     标记型语言: html是标记型语言\n –也是使用标签来操作\n•     可扩展:\n​     –html里面的标签是固定，每个标签都有特定的含义   –标签可以自已定义,可以写中文的标签&lt;/person、&lt;猫&gt;&lt;/猫&gt;\n3.xml用途\n–     html是用于显示数据，xml也可以湿示数据（不是主要功能)\n–     xml主要功能，为了存储数据\n•     xml是w3c组织发布的技术\nxml有两个版本1.01.1-使用都是1.0版本，(1.1版本不能向下\nXML的应用内容介绍1.不同的系统之间传输数据\n2.用来表示生活中有关系的数据\n3.经常用在配置文件\n1.不同的系统之间传输数据•     QQ之间数据的传输\n•     画图分析过程\n\n2.用来表示生活中有关系的数据\n•     XML语言出现的根本目的在于描述向上图那种有关系的数据。\n•     XML是―种通用的数据交换格式标签。\n•     在xml语言中它允许用户自定义标签。—个标签用于描述一段数据；一个标签可分为开始标整和结束标签,在起始标签之间,又可以使用其它标签描述其它数据，以此来实现数据之间关系的描述。\n•     XML中的教据必须通过软件程序来解析执行或显示，如iE这样的解析程序称之为Pars er(解析器)。\n3.经常用在配置文件•     例如现在连接数据库知道数据库的用户名和密码，数据名称\n•     修改数据库的信息，不需要修改源代码，只要修改配置文件就可以了\nXML的文档声明\n创建一个文件后缀名是.xml\n\n如果写xml，第一步必须要有一个文档声明（写了文档声明之后，表示写xml文件的内容）\n"},{"title":"网易云移除已购音乐的加密保护","url":"/2022/09/30/%E7%BD%91%E6%98%93%E4%BA%91%E7%A7%BB%E9%99%A4%E5%B7%B2%E8%B4%AD%E9%9F%B3%E4%B9%90%E7%9A%84%E5%8A%A0%E5%AF%86%E4%BF%9D%E6%8A%A4/","content":"网易云移除已购音乐的加密保护起因\n网易云音乐黑胶续不起了\n 但是好想听音乐呐，不听音乐真的会死捏\n\n于是便找到了这个网站\n移除已购音乐的加密保护\n\n下载压缩包下来后打开里面的html文件是这个样子的，最终我把这个月网易云音乐包用完了，下了几百首歌，全部通过他转mp3了，巧了我正好开始学web，而这个本地静态网站可以实现功能好棒，直接仰视大佬，打开我新世界的大门了。\n使用把在网易云下载的加密音乐(.ncm音乐文件)拉进去就可以喽，下载下来的就是解密的mp3文件呐\n然后捏发现这个网站是出自从下面的网站\n刘明野的工具箱\n\n下载下来的音乐当然需要一个新播放器来播放了\n这里选择的Dopamine，非常不错的离线音乐播放软件\n\n"},{"title":"Python基础语法","url":"/2022/04/18/Python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/","content":"BearKouber的Python学习记录\n简单的笔记\nPython保留字\n\n\n序号\n保留字\n说明\n\n\n\n1\nand\n逻辑与操作，用于表达式运算\n\n\n2\nas\n用于转换数据类型\n\n\n3\nassert\n用于判断变量或条件表达式的结果\n\n\n4\nasync\n用于启用异步操作\n\n\n5\nawait\n用于异步操作中等待协程返回\n\n\n6\nbreak\n中断循环语句的执行\n\n\n7\nclass\n定义类\n\n\n8\ncontinue\n继续执行下一次循环\n\n\n9\ndef\n定义函数或方法\n\n\n10\ndel\n删除变量或序列的值\n\n\n11\nelif\n条件语句，与 if、else 结合使用\n\n\n12\nelse\n条件语句，与 if、else 结合使用；也可用于异常或循环语句\n\n\n13\nexcept\n包含捕获异常后的处理代码块，与 try、finally 结合使用\n\n\n14\nFalse\n含义为“假”的逻辑值\n\n\n15\nfinally\n包含捕获异常后的始终要调用的代码块，与 try、except 结合使用\n\n\n16\nfor\n循环语句\n\n\n17\nfrom\n用于导入模块，与 import 结合使用\n\n\n18\nglobal\n用于在函数或其他局部作用域中使用全局变量\n\n\n19\nif\n条件语句，与 elif、else 结合使用\n\n\n20\nimport\n导入模块，与 from 结合使用\n\n\n21\nin\n判断变量是否在序列中\n\n\n22\nis\n判断变量是否为某个类的实例\n\n\n23\nlambda\n定义匿名函数\n\n\n24\nNone\n表示一个空对象或是一个特殊的空值\n\n\n25\nnonlocal\n用于在函数或其他作用域中使用外层（非全局）变量\n\n\n26\nnot\n逻辑非操作，用于表达式运算\n\n\n27\nor\n逻辑或操作，用于表达式运算\n\n\n28\npass\n空的类、方法或函数的占位符\n\n\n29\nraise\n用于抛出异常\n\n\n30\nreturn\n从函数返回计算结果\n\n\n31\nTrue\n含义为“真”的逻辑值\n\n\n32\ntry\n测试执行可能出现异常的代码，与 except, finally 结合使用\n\n\n33\nwhile\n循环语句\n\n\n34\nwith\n简化 Python 的语句\n\n\n35\nyield\n从函数依次返回值\n\n\n\n在 Python 环境下可以执行以下命令查看当前版本的保留字：\n\n\\&gt;&gt;&gt;import keyword\\&gt;&gt;&gt;keyword.kwlist['False', 'None', 'True', 'and', 'as', 'assert', 'async', 'await', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield']\n\n\n若将保留字作为标识符并赋值将会得到语法错误\n\n\\&gt;&gt;&gt;class=\"This is a class\"SyntaxError: invalid syntax\n\n温度转化#Tempconvert.pyTempStr = input(\"宝，快输入带有符号的温度值 :\")if TempStr[-1] in ['F','f']:      #分支语句，如果条件正确，则执行冒号后面缩进的语句，反之跳过    #TemStr[-1]指倒数数组第一个元素，in判断左边元素有没有在右边数组里面    C = (eval(TempStr[0:-1])-32)/1.8    print(\"转换后的温度是{:.2f}C\".format(C))elif TempStr[-1] in ['C','c']:    F = 1.8*eval(TempStr[0:-1])+32    #此处TemStr[0:-1]是这个字符串去掉最后一个单位后的一串数字    print(\"转换后的温度是{:.2f}F\".format(F))else:    print(\"输入格式错误\")\n\n分支语句由判断条件决定程序运行方向的语句\n\n保留字：if elif else\n语法：每个保留字所在行末存在:\n\n函数输入函数input()从控制台获得用户输入的函数\n\n格式：&lt;变量&gt; = input(提示信息字符串)\n用户输入的信息以字符串的内容保存在&lt;变量&gt;中\n\n输出函数\n格式：print(&lt;拟输出字符串或字符串变量&gt;)\n格式化：print(\"转化后的温度是{:.2f}\".format(C))，{}表示槽，后续变量填充到槽中，{:.2f}表示将变量C填充到这个位置时取小数点后两位\n\n如果C为123.456，则输出结果为123.45\neval\n去掉参数最外侧引号并执行余下语句的函数\n\neval(\"1\")1eval(\"1+2\")3eval('\"1+2\"')'1+2'eval('print(\"hello\")')hello\n\nturtle库#PythonDraw.pyimport turtle#引入绘图库turtleturtle.setup(650, 350, 200, 200)#绘制画图表格turtle.penup()#抬笔turtle.fd(-250)#倒车turtle.pendown()#落笔turtle.pensize(25)#画笔粗细turtle.pencolor(\"purple\")#画笔颜色turtle.seth(-40)#方向为-40°for i in range(4):    turtle.circle(40, 80)    turtle.circle(-40, 80)#画两条曲线，循环四次turtle.circle(40, 80/2)#半径40，旋转40°turtle.fd(40)#前进40turtle.circle(16, 180)#半径16，旋转180turtle.fd(40 * 2/3)turtle.done()#最后行的作用是运行完留下窗体(双击.py文件后)\n\nturtle的绘图窗体setup()turtle.setup(width, heigth, startx, starty)\n\n\nsetup()设置窗体大小及位置\n4各参数中后两个可选\nsetup()不是必须的\nsetup()括号内参数可以选择性填写\n\n画线goto()turtle.goto(x,y)\n\n绘制一条从乌龟所在处到坐标(x,y)处的直线\n勇敢龟龟向前冲turtle.circle(r,angle)turtle.fd(d)turtle.bk(d)\n\n\ncircle(r,angle)朝海龟面向r方向旋转前进angle\nturtle.circle(r,extend)：根据半径r绘制extend角度的弧形\n默认圆心在龟龟左侧r距离的位置\nextend：绘制角度，不写此参数默认是360度整圆\n\n\nfd(d)前进d\nturtle.forward(d) –&gt; turtle.fd(d)：直线向前d\nd可以为负数\n\n\nbk(d)后退d，但是面朝前\n\n勇敢龟龟转弯turtle.seth(angle)turtle.left(angle)turtle.right(angle)\n\n\nseth(angle)改变龟龟面向方向到angle，原地转向\nturtle.setheading(angle) –&gt; turtle.seth(angle)\nangle为龟龟转后面朝的方向\n\n\nleft(angle)左转angle\nright(angle)右转angle\nangle为绝对度数\n\n勇敢龟龟路径变色turtle.colormode(mode)\n\n\nmode值为1.0：RGB小数值模式\nmode值为255：RGB整数值模式\n\nRGB色彩(由三种颜色构成的万物色)小知识\nRGB指红蓝绿三个通道的颜色组合\n覆盖视力所能感知的所有颜色\nRGB每色取值范围0-255整数或0-1小数\n\n常用RGB色彩\n白色：rgb(255,255,255)\n黑色：rgb(0,0,0)\n红色：rgb(255,0,0)\n绿色：rgb(0,255,0)\n蓝色：rgb(0,0,255)\n青色：rgb(0,255,255)\n紫色：rgb(255,0,255)\n\nimport库引用扩充Python程序功能的方式\n\n使用import保留字完成，采用,()编码风格\n使用库方法：import &lt;库名&gt;\n使用该库函数方法：&lt;库名&gt;.&lt;函数名&gt;(&lt;函数参数&gt;)\n\n其他用法1.使用from和import保留字共同完成from &lt;库名&gt; import*\n\n使用import*修改原代码可得\nfrom turtle import*setup(650, 350, 200, 200)penup()fd(-250)pendown()pensize(25)pencolor(\"purple\")seth(-40)for i in range(4):    turtle.circle(40, 80)    turtle.circle(-40, 80)circle(40, 80/2)fd(40)circle(16, 180)fd(40 * 2/3)done()\n\n2.使用import和as保留字共同完成import &lt;库名&gt; as &lt;库别名&gt;\n\n\n给调用的外部库关联一个更短更适合自己的名字\n\nimport turtle as t#引入绘图库turtlet.setup(650, 350, 200, 200)t.penup()t.fd(-250)t.pendown()t.pensize(25)t.pencolor(\"purple\")t.seth(-40)for i in range(4):    turtle.circle(40, 80)    turtle.circle(-40, 80)t.circle(40, 80/2)t.fd(40)t.circle(16, 180)t.fd(40 * 2/3)t.done()\n\n画笔控制函数画笔操作后一直有效，一般成对出现\n抬起画笔，龟龟在飞行\nturtle.penup()\nturtle.pu()\n\n落下画笔，龟龟爬行\nturtle.pendown()\nturtle.pd()\n\n画笔设置后一直有效，直至下次重新设置\n龟龟腰围\nturtle.pensize(width)\nturtle.width(width)\n设置画笔宽度，当无参数输入时返回当前画笔宽度\n\n龟龟颜色\nturtle.pencolor(color)\n\ncolor有三种形式\n颜色字符串：turtle.pencolor(\"purple\")\nRGB的小数值：turtle.pencolor(0.63,0.13,0.94)\nRGB的元组值：turtle.pencolor((0.63,0.13,0.94))\n\n循环语句按照一定次数循环执行\nfor &lt;变量&gt; in range (&lt;参数&gt;)\t&lt;被循环执行的语句&gt;\n\n\n变量：每次循环的计数，0到次数-1\n\nfor i in range(5):    print(i)01234\n\nrange()函数产生循环计数序列\n\nrange(N):产生0到N-1的正数序列，共N个\nrange(M,N):产生M到N-1的整数序列，共N-M个\nrange(start, stop, step)\nstart：表示从返回序列的起始编号，默认情况下从0开始\nstop：表示生成最多但不包括此数字的数字\nstep：指的是序列中每个数字之间的差异，默认值为1\n\n\n\nx = range(4, 21, 5)for n in x:    print(n)    491419\n\n数字类型与操作整型\n可正可负，没有取值范围限制\n\n四种进制表示形式\n\n十进制\n二进制以0b或0B开头\n八进制，以0o或0O开头\n十六进制，以0x或OX开头\n\n\n\npow(x,y)\n计算x的y次方，无长度限制\n\n浮点类型运算存在不确定尾数，不是bug0.1 + 0.30.40.1 + 0.20.300000000000000040.1 + 0.2 == 0.3False\n\n[为什么](为什么0.1+0.2=0.30000000000000004 - 月井石 - 博客园 (cnblogs.com))\n解决方法round()round(0.1+0.2, 1) == 0.3True\n\n\nround(x, d):对x四舍五入，d是小数截取位数\n浮点数间运算及比较用round()函数辅助\n不确定尾数一般发生在10的负16次方左右，round()十分有效\n\n科学计数法\n使用字母e或E作为幂的符号，以10为基数，格式如下：\ne 表示a乘10的b次方\n\n\n\n5e2500.0\n\n复数类型\nz = 1.23e-4 + 5.6e+89jprint(z.real)0.000123\n\n数值运算操作符\n\n\nx//y\n整数除，x与y之整数商 10//3结果是3\n\n\n\nx**y\n幂运算x的y次方，当y是小数时，开方运算\n\n\n数字类型的关系类型间可进行混合运算，生成结果为”最宽”类型\n整数 –&gt; 浮点数 –&gt; 复数\n数值运算函数abs()：计算绝对值abs(-10)10\n\ndivmod()：计算商与余数\n返回的元组第一个是整数商，第二个是余数\n\na,b=divmod(10,3)print(a,b)3 1\n\npow()函数：计算幂次方\n可以有三个参数\npow(x,y):x的y次方\npow(x,y,z):(x**y)%z\n可以求一个数的后n位\n\na = pow(3,2)b = pow(3,2,2)print(a,b)9 1\n\n\n\nc = pow(3,10,100)print(c)49\n\nround()：返回浮点数的四舍五入值\nround(x)\nround(x,n):n是保留小数位数\n\na = round(-10.2365)b = round(-10.2365,2)print(a,b)-10 -10.24\n\nmax()和min()\nmax()计算多个数字里面的最大值\nmin()计算多个数字里面的最小值\n\nS = [1,2,3,6,5,4,7,8,654,0,-456]print(max(S))print(min(S))654-456\n\nint(x):将x变成整数，舍弃小数部分int(123.45)123int(\"1234\")1234\n\nfloat(x):将x变成浮点数，增加小数部分float(12)12.0float(\"1.23\")1.23\n\ncomplex:将x变成复数，增加虚数部分complex(4)(4+0j)\n\n例\n#DayDayUp.pydef dayUP(df):    dayup = 1    for i in range(365):        if i in range\n\n字符串有两类共四种表示方法\n\n由一对单引号或双引号表示，仅表示单行字符串\n由一对三单引号或三双引号表示，可表示多行字符串\n\n'''Python\t\t\t\t\t语言 '''\n\n\npython里面没有真正提供多行注释，三单引号其实是字符串\n\n字符串中出现单引号或双引号怎么办使用转义符 \\\n转义表达特定字符的本意\n\nprint(\" 双引号\\\" \") 双引号\" \n\n\n\n\n转义符形成的一些组合，表达一些不可打印的含义：\\b回退，\\r回车\n\n不使用转义符\n出现单引号，使用双引号表示字符串\n出现双引号，使用单引号表示字符串\n都出现，使用三引号表示字符串\n\n字符串切片\n字符串[M:N:K]\n\nM缺失表示至开头，N缺失表示至结尾\n\nK为根据步长K对字符串切片\n\n返回字符串中一段字符字串\n\n\nname = \"BearKouber\"print(name[4:-1])Koubeprint(name[4:])Kouberprint(name[::2])BaKueprint(name[::-1])rebuoKraeB\n\n字符串操作符\n\n\n操作符及使用\n描述\n\n\n\nx + y\n连接两个字符串x和y\n\n\nn * x 或 x * n\n复制n次字符串x\n\n\nx in s\n如果x是s的字串，返回True，否则返回False\n\n\n星期转换直接版本#weekname.pyweek = \"星期一星期二星期三星期四星期五星期六星期日\"weekId = eval(input())pos = (weekId - 1) * 3print(week[pos:pos+3])\n\n优化版本#weekname.pyweek = [\"一二三四五六日\"]weekId = eval(input())print(\"星期\" + week[weekID-1])weedId = eval(input(\"请输入星期数字(1-7)\"))\n\n常用函数len()str()hex() oct()chr()ord()\n\n\n函数\n作用\n\n\n\nlen(x)\n返回字符串x的长度\n\n\nstr(x)\n任意类型x所对应的字符串形式，与eval相反\n\n\nhex(x)或oct(x)\n整数x的十六进制或八进制小写形式字符串\n\n\nchr(u)\nu为Unicode编码，返回其对应的字符\n\n\nord(x)\nx为字符，返回其对应的Unicode编码\n\n\n\nUnicode编码字符串处理方法\n\n\n方法及使用\n描述\n\n\n\nstr.lower  /  str.upper\n全部字符小写/大写\n\n\nstr.split(sep=None)\n返回一个列表，由str根据sep被分隔的部分组成\n\n\nstr.count(sub)\n返回子串sub在str中出现的次数\n\n\nstr.replace(old,new)\n所有old子串被替换为new\n\n\nstr.center(width[,fillchar])\n字符串str根据宽度width居中，fillchar可选\n\n\nstr.strip(chars)\n从str中去掉在其左侧和右侧chars中列出的字符\n\n\nstr.join(iter)\n在iter变量除最后元素外每个元素后增加一个str，主要用于字符串分隔\n\n\n举例\"AbCdEfGh\".lower()'abcdefgh'\"A,B,C\".split(\",\")['A', 'B', 'C']\"an apple\".count(\"a\")2\"BearKouber\".replace(\"r\",\"rr.tt\")'Bearr.ttKouberr.tt'\"BearKouber\".center(20,\"-\")'-----BearKouber-----'\"-- Bear Koub e r--\".strip(\" -Bber\")'ar Kou'\",\".join(\"123456\")'1,2,3,4,5,6'\n\n字符串格式化.format()方法\n格式化是对字符串进行格式表达的方式\n\n&lt;模板字符串&gt;.format(&lt;都好分隔的参数&gt;)\n\"{}:计算机{}的CPU占用率为{}%\".format(\"2018-10-10\",\"C\",10)'2018-10-10:计算机C的CPU占用率为10%'\"{2}:计算机{0}的CPU占用率为{1}%\".format(\"2018-10-10\",\"C\",10)'10:计算机2018-10-10的CPU占用率为C%'\n\nformat()方法的格式控制\n\n\n:\n&lt;填充&gt;\n&lt;对齐&gt;\n&lt;宽度&gt;\n&lt;,&gt;  &lt;.精度&gt;  &lt;类型&gt;\n\n\n\n引导符号\n用于填充的单个字符\n&lt; 左对齐  &gt;右对齐   ^居中对齐\n槽设定的输出宽度\n\n\n\n\n\n\n&lt;,&gt;\n&lt;.精度&gt;\n&lt;类型&gt;\n\n\n\n数字的千位分隔符\n浮点数小数精度或字符串最大输出长度\n整数类型b,c,d,o,x,X浮点数类型e,E,f,%\n\n\nfor example\n\"{0:=^20}\".format(\"PYTHON\")'=======PYTHON======='\"{0:*&gt;20}\".format(\"BIT\")'*****************BIT'\"{:10}\".format(\"BIT\")'BIT       '#默认情况下填充为空格\"{0:,.2f}\".format(12345.6789)'12,345.68'\"{0:b},{0:c},{0:d},{0:o},{0:x},{0:X}\".format(425)'110101001,Ʃ,425,651,1a9,1A9'\"{0:e},{0:E},{0:f},{0:%}\".format(3.14)'3.140000e+00,3.140000E+00,3.140000,314.000000%'\n\ntime库的使用time()ctime()gmtime()\n\n\n函数\n描述\n\n\n\ntime()\n获取当前时间戳，即计算机内部时间值(浮点数)time.time()\n\n\nctime()\n获取当前时间并以易读方式表示，返回字符串time.ctime()\n\n\ngmtime()\n获取当前时间，表示为计算机可处理的时间格式time.gmtime()\n\n\n\ntime()获取从1970年1月1日0:00开始到现在的时间(秒/s)\n\nctime()是time库里面获取清楚时间的最简单的函数\n\ngmtime()获取的格式被称为struct_time格式 \n\n\n时间格式化strftime()strptime()将时间以合理方式展示出来\n\n\n\n函数\n描述\n\n\n\nstrftime(tpl,ts)\ntpl是格式化模板字符串，用来定义输出结果ts是计算机内部时间类型变量\n\n\nstrptime(str,tpl)\nstr是字符串形式的时间值 tpl是格式化模板字符串，用来定义输入效果\n\n\nstrftime()\nt = time.gmtime()time.strftime(\"%Y-%m-%d %H:%M:%S\",t)'2022-05-01 07:15:14'\n\nstrptime()  \ntimeStr = '2022-05-01 07:15:14'time.strptime(timeStr,\"%Y-%m-%d %H:%M:%S\")time.struct_time(tm_year=2022, tm_mon=5, tm_mday=1, tm_hour=7, tm_min=15, tm_sec=14, tm_wday=6, tm_yday=121, tm_isdst=-1)\n\n六个时间格式化控制符\n\n\n格式化字符串\n日期/时间说明\n值范围和实例\n\n\n\n%a\n星期缩写\nMon~Sun，例如：Wed\n\n\n%H\n小时(24h制)\n00~23，例如：12\n\n\n%I\n小时(12h制)\n01~12，例如：7\n\n\n%p\n上/下午\nAM，PM，例如：PM\n\n\n%M\n分钟\n00~59，例如：26\n\n\n%S\n秒\n00~59，例如：26\n\n\n程序计时\n程序计时指测量起止动作所经历时间的过程\n测量时间：perf_counter()\n产生时间：sleep()\n\n\n\n\n函数\n描述\n\n\n\nperf_counter()\n返回一个CPU级别的精确时间计数值，单位为秒，由于这个计数起点不确定，连续调用差值才有意义\n\n\nsleep(s)\ns拟休眠的时间，单位是秒，可以是浮点数\n\n\nperf_counter()start = time.perf_counter()170007.1174668end = time.perf_counter()170037.5930695end - start30.47560269999667\n\nsleep()def wait():    time.sleep(3.3)wait()\t#程序将等待3.3秒后再退出\n\n文本进度条文本进度条 简单的开始\n#TextProBarV1.pyimport timescale = 10print(\"------执行开始------\")for i in range(scale+1):    a = '*' * i    b = '.' * (scale - i)    c = (i/scale)*100    print(\"{:^3.0f}%[{}-&gt;{}]\".format(c,a,b))    time.sleep(0.1)print(\"------执行结束------\")------执行开始------ 0 %[-&gt;..........]10 %[*-&gt;.........]20 %[**-&gt;........]30 %[***-&gt;.......]40 %[****-&gt;......]50 %[*****-&gt;.....]60 %[******-&gt;....]70 %[*******-&gt;...]80 %[********-&gt;..]90 %[*********-&gt;.]100%[**********-&gt;]------执行结束------\n\n文本进度条 单行动态刷新#TextProBarV2.pyimport timefor i in range(101):    print(\"\\r{:3}%\".format(i), end=\"\")    time.sleep(0.1)#此处\\r是使每次打印都能使光标退回到当前行的行首#此处默认end为\"\\n\",如果不想要print换行就把它改为空#此程序在IDLE上F5运行不会出现单行刷新的效果而是把进度全部输出，需要在控制台执行才能实现单行刷新\n\n文本进度条 实例完整效果#TextProBarV3.pyimport timescale = 50print(\"执行开始\".center(scale//2, \"-\"))start = time.perf_counter()for i in range(scale+1):    a = '*' * i    b = '.' * (scale - i)    c = (i/scale)*100    dur = time.perf_counter() - start    print(\"\\r{:^3.0f}%[{}-&gt;{}]{:.2f}s\".format(c,a,b,dur),end='')    time.sleep(0.1)print(\"\\n\"+\"执行结束\".center(scale//2,'-'))\n\n分支结构单分支结构根据判断结果而选择不同向前路径的运行方式    \n单分支示例\nguess = eval(input())if guess == 99:    print(\"猜对了\")\n\n二分支结构根据判断条件结果而选择不同向前路径的运行方式\n示例\nguess = eval(input())if guess == 99:    print(\"猜对了\")else :    print(\"猜错了\")\n\n二分支紧凑形式&lt;表达式1&gt; if &lt;条件&gt; else &lt;表达式2&gt;\nguess = eval(input())print(\"猜{}了\".format(\"对\" if guess==99 else \"错\"))\n\n使用此形式没有赋值过程\n多分支结构score = eval(input())if score &gt;= 90:    grade = \"A\"elif score &gt;= 80:    grade = \"B\"elif score &gt;= 70:    grade = \"C\"elif score &gt;= 60:    grade = \"D\"else :    grade = \"E\"print(\"输出成绩属于级别{}\".format(grade))\n\n条件组合保留字\n\n\n操作符\n描述\n\n\n\nx and y\n两个条件x和y的逻辑与\n\n\nx or y\n两个条件x和y的逻辑或\n\n\nnot x\n条件x的逻辑非\n\n\n示例\nguess = eval(input())if guess &gt; 99 or guess &lt; 99:    print(\"猜错了\")else :    print(\"猜对了\") \n\n异常处理try :    &lt;语块1&gt;except &lt;异常类型&gt; :  #此处异常类型不写相应所有异常，写了表示为仅相应该异常类型    &lt;语块2&gt;\n\n示例\ntry :    num = eval(input(\"请输入一个整数:\"))    print(num**2)except NameError:    print(\"输入不是整数\")\n\n高级使用try :    &lt;语块1&gt;except :    &lt;语块2&gt;else : #对应语块3在不发生异常时执行    &lt;语块3&gt;finally : #对应语块4一定执行    &lt;语块4&gt;\n\n身体质量指数BMI#CalBMIv3.pyheight, weight = eval(input(\"请输入身高(米)和体重(公斤)[逗号隔开]: \"))bmi = weight / pow(height, 2)print(\"BMI 数值为：{:.2f}\".format(bmi))who, nat = \"\", \"\"if bmi &lt; 18.5:    who, nat = \"偏瘦\", \"偏瘦\"elif 18.5 &lt;= bmi &lt; 24:    who, nat = \"正常\", \"正常\"elif 24 &lt;= bmi &lt; 25:    who, nat = \"正常\", \"偏胖\"elif 25 &lt;= bmi &lt; 28:    who, nat = \"偏胖\", \"偏胖\"elif 28 &lt;= bmi &lt; 30:    who, nat = \"偏胖\", \"肥胖\"else:    who, nat = \"肥胖\", \"肥胖\"print(\"BMI 指标为:国际'{0}', 国内'{1}'\".format(who, nat))\n\n\n 注意：多分支条件不要互相覆盖，阅读代码先看分支条件再看分支语句\n\n循环遍历循环for &lt;循环变量&gt; in &lt;遍历结构&gt; :    &lt;语句块&gt;\n\n\n每次循环，从遍历结构中所获得的元素放入循环变量，并执行一次语句块\n\n计数循环for i in range(N) :    &lt;语句块&gt;\n\n\n遍历由range()函数产生的数字序列，产生循环\n\nfor i in range(M,N,K) :    &lt;语句块&gt;#range(M,N,K)会产生一个数字序列，从M开始到N之前的整数结束，每个数之间以K为步长\n\n字符串遍历循环for c in s:    &lt;语句块&gt;\n\n\ns是字符串，遍历字符串每个字符，产生循环\n\n列表遍历循环for item in ls :    &lt;语句块&gt;\n\n\nls是一个列表，遍历其每个元素，产生循环\n\nfor item in [123,\"PY\",456] :    print(item,end=\",\")    123,PY,456,\n\n文件遍历循环for line in fi :    &lt;语句块&gt;\n\n\nfi是一个文件标识符，遍历其每行，产生循环\n\nfi = open(\"C:/Users/BearKouber/Desktop/py/fi.txt\",'r',encoding='UTF-8')for line in fi :    print(line)2022.5.2看完去洗脸刮胡子洗漱完毕去吃饭吃完饭去学校\n\n无限循环while &lt;条件&gt; :    &lt;语句块&gt;\n\n\n反复执行语句块，直到条件不满足时结束\n\n循环控制保留字break和continue\nbreak跳出并结束当兵前整个循环，执行循环后的语句\ncontinue结束档次循环，继续执行后续次数循环\n\n例for\nfor c in \"Python\":    if c == \"t\" :        continue    print(c, end=\"\")Pyhonfor c in \"Python\":    if c == \"t\" :        break    print(c, end=\"\")Py\n\n例while\ns = \"Python\"while s != \"\" :    for c in s :        print(c, end=\"\")    s = s[:-1]PythonPythoPythPytPyPs = \"Python\"while s != \"\" :    for c in s :        if c == \"t\":            break  #此break仅跳出当前最内层循环即for循环       \tprint(c, end=\"\")    s = s[:-1]PyPyPyPyPyP\n\n循环的扩展：else\n执行break不执行else，无break执行则else执行\n\ncontinue\nfor c in \"PYTHON\" :    if c == \"T\":        continue    print(c, end=\"\")else:    print(\"正常退出\")PYHON正常退出\n\nbreak\nfor c in \"PYTHON\" :    if c == \"T\":        break    print(c, end=\"\")else:    print(\"正常退出\")PY\n\nrandom库\n伪随机数：采用梅森旋转算法生成的(伪)随机序列中元素\nrandom库主要用于生成随机数\n\n\n\n\n函数\n描述\n\n\n\nseed(a=None)\n初始化给定的随机数种子，默认为当前系统时间\n\n\nrandom()\n生成一个[0.0,1.0]之间的随机小数\n\n\nimport randomrandom.seed(10)random.random()0.5714025946899135random.random()0.4288890546751146\n\n不给种子的话，默认种子是调用random()函数所对应的时间\n为什么要给种子？编程中给出了随机种子下次在此运行程序，只要种子相同，那么产生的随机数也是相同的，可以再现系统运行的数据\nimport randomrandom.seed(10)random.random()0.5714025946899135random.seed(10)random.random()0.5714025946899135\n\n扩展随机数函数\n\n\n函数\n描述\n\n\n\nrandint(a,b)\n生成一个[a,b]之间的整数\n\n\nrandrange(m,n,k)\n生成一个[m,n]之间以k为步长的随机整数，k默认为1\n\n\ngetrandbits(k)\n生成一个k比特长的随机整数\n\n\nuniform(a,b)\n生成一个[a,b]之间的随机小数\n\n\nchoice(seq)\n从序列seq中随机选择一个元素\n\n\nshuffle(seq)\n将序列seq中元素随机排列，返回打乱后的序列\n\n\n如果在编写Python代码中非常必要把代码写在一行中，那么每行代码需要用;分开\n圆周率的计算\n公式法#CalPiV1.pypi = 0N = 100for k in range(N):    pi += 1/pow(16,k)*( \\              4/(8*k+1) - 2/(8*k+4) - \\              1/(8*k+5) - 1/(8*k+6) ) print(\"圆周率值是: {}\".format(pi))圆周率值是: 3.141592653589793\n\n\n一行太长可以加斜杠\\接着这一行写\n\n蒙特卡罗方法#CalPiV2.pyfrom random import randomfrom time import perf_counterDARTS = 1000*1000hits = 0.0start = perf_counter()for i in range(1, DARTS+1):    x, y = random(), random()    dist = pow(x ** 2 + y ** 2, 0.5)    if dist &lt;= 1.0:        hits = hits + 1pi = 4 * (hits/DARTS)print(\"圆周率值是: {}\".format(pi))print(\"运行时间是: {:.5f}s\".format(perf_counter() - start))圆周率值是: 3.142936运行时间是: 0.58529s\n\n函数函数定义def &lt;函数名&gt;(&lt;参数(0个或多个)&gt;):    &lt;函数体&gt;    return &lt;返回值&gt;\n\n\n函数定义时，所指定的参数是一种占位符\n函数定义后，如果不经过调用，不会被执行\n函数定义时，参数是输入、函数体是处理、结果是输出(IPO)\n\n#DayDayUpQ4.pydef dayUP(df):    dayup = 1    for i in range(365):       if i % 7 in [6,0]:           dayup = dayup*(1 - 0.01)       else:           dayup = dayup*(1 + df)    return dayupdayfactor = 0.01while dayUP(dayfactor) &lt; 37.78:    dayfactor += 0.001print(\"工作日的努力参数是：{:.3f} \".format(dayfactor))\n\n可选参数传递函数定义时可以为某些参数指定默认值，构成可选参数\n要求在设计和定义的时候，所有的可选参数要放非可选参数后\ndef fact(n, m=1) :    s = 1    for i in range(1,n+1):        s *=i    return s//m\n\n如果给了第二个参数m那么就用给的参数值，如果没给的话就默认为m=1\nfact(10)3628800fact(10,5)725760\n\n可变参数传递函数定义时可以设计可变数量参数，及不确定参数总数量\ndef &lt;函数名&gt;(&lt;参数&gt;, *b):    &lt;函数体&gt;    return &lt;返回值&gt;*b及指不确定的n个参数，b可以换做其他变量名\n\n计算n！def fact(n, *b) :    s = 1    for i in range(1, n+1):        s *= i    for item in b:        s *= item    return sfact(10,3)10886400fact(10, 3, 5 , 8)435456000\n\n函数的返回值函数可以返回0个或多个结果\ndef fact(n, m=1) :    s = 1    for i in range(1, n+1):        s *= i    return s//m, n, mfact(10, 5)(725760, 10, 5)a,b,c = fact(10,5)print(a,b,c)725760 10 5\n\n全局变量与局部变量大致与c语言一致\nglobal在函数内使用global定义变量则此变量为全局变量\n此外\n函数外定义的数组a，函数内如果也用同样变量名定义，那么函数内的数组变量为局部变量 \n\n当然直接在函数内定义与外部变量名不一样的数组也为局部变量\n\n\nlambda:不建议使用此方法定义函数\nlambda函数是一种匿名函数，即没有名字的函数\n使用lambda保留字定义，函数名是返回结果\nlambda函数用于定义简单的，能够在一行内表示的函数\n\n&lt;函数名&gt; = lambda &lt;参数&gt;:&lt;表达式&gt;\t等价为def &lt;函数名&gt;(&lt;参数&gt;):    &lt;函数体&gt;    return &lt;返回值&gt;\n\n例\nf = lambda x, y : x+yf(10, 15)25f = lambda : \"lambda函数\"print(f())lambda函数\n\n三目运算在python中，可以通过 同一行的if else语句 实现类似的三目运算(条件运算)：\nTrue_statements if expression else False_statements\n\n\n运算规则是：先对逻辑表达式 expression 求值，如果逻辑表达式返回 True，则 执行并返回 True_statements 的值；如果逻辑表达式返回 False，则执行并返回 False_statements 的值。\n\n七段数码管绘制一import turtledef drawLine(draw):   #绘制单段数码管    turtle.pendown() if draw else turtle.penup()    turtle.fd(40)    turtle.right(90)def drawDigit(digit): #根据数字绘制七段数码管    drawLine(True) if digit in [2,3,4,5,6,8,9] else drawLine(False)    drawLine(True) if digit in [0,1,3,4,5,6,7,8,9] else drawLine(False)    drawLine(True) if digit in [0,2,3,5,6,8,9] else drawLine(False)    drawLine(True) if digit in [0,2,6,8] else drawLine(False)    turtle.left(90)    drawLine(True) if digit in [0,4,5,6,8,9] else drawLine(False)    drawLine(True) if digit in [0,2,3,5,6,7,8,9] else drawLine(False)    drawLine(True) if digit in [0,1,2,3,4,7,8,9] else drawLine(False)    turtle.left(180)    turtle.penup()    turtle.fd(20) def drawDate(date):  #获得要输出的数字    for i in date:        drawDigit(eval(i))  #通过eval()函数将数字变为整数def main():    turtle.setup(800, 350, 200, 200)    turtle.penup()    turtle.fd(-300)    turtle.pensize(5)    drawDate('20181010')    turtle.hideturtle()    turtle.done()main()\n\n七段数码管版本二import turtle, timedef drawGap(): #绘制数码管间隔    turtle.penup()    turtle.fd(5)def drawLine(draw):   #绘制单段数码管    drawGap()    turtle.pendown() if draw else turtle.penup()    turtle.fd(40)    drawGap()    turtle.right(90)def drawDigit(d): #根据数字绘制七段数码管    drawLine(True) if d in [2,3,4,5,6,8,9] else drawLine(False)    drawLine(True) if d in [0,1,3,4,5,6,7,8,9] else drawLine(False)    drawLine(True) if d in [0,2,3,5,6,8,9] else drawLine(False)    drawLine(True) if d in [0,2,6,8] else drawLine(False)    turtle.left(90)    drawLine(True) if d in [0,4,5,6,8,9] else drawLine(False)    drawLine(True) if d in [0,2,3,5,6,7,8,9] else drawLine(False)    drawLine(True) if d in [0,1,2,3,4,7,8,9] else drawLine(False)    turtle.left(180)    turtle.penup()    turtle.fd(20)def drawDate(date):    turtle.pencolor(\"red\")    for i in date:        if i == '-':            turtle.write('年',font=(\"Arial\", 18, \"normal\"))            turtle.pencolor(\"green\")            turtle.fd(40)        elif i == '=':            turtle.write('月',font=(\"Arial\", 18, \"normal\"))            turtle.pencolor(\"blue\")            turtle.fd(40)        elif i == '+':            turtle.write('日',font=(\"Arial\", 18, \"normal\"))        else:            drawDigit(eval(i))def main():    turtle.setup(800, 350, 200, 200)    turtle.penup()    turtle.fd(-350)    turtle.pensize(5)#   drawDate('2018-10=10+')    drawDate(time.strftime('%Y-%m=%d+',time.gmtime()))    turtle.hideturtle()    turtle.done()main()\n\n代码复用函数和对象是代码复用的两种主要方式\n\n函数:将代码命名，在代码层面建立了初步抽象\n对象:属性和方法，&lt;a&gt;.&lt;b&gt;和&lt;a&gt;.&lt;b&gt;()在函数之上再次组织进行抽象\n\n\n那么我对此的看法是，这不就是java+c吗，有点东西啊我giao\n\n模块化设计\n通过函数或对象封装将程序划分为模块及模块间的表达\n具体包括：主程序、子程序和子程序间的关系\n分而治之：一种分而治之、分层抽象、体系化的设计思想\n\n紧耦合 松耦合\n第一次见到这个词还是在学习Java时候听某哥哥说的\n\n简单来说便是\n\n紧耦合：两个部分之间交流很多，无法独立存在\n松耦合：两个部分之间交流很少，可以独立存在\n模块内部紧耦合、模块之间松耦合\n\n递归两个关键特征\n\n链条：计算过程存在递归链条\n基例：存在一个或多个不需要再次递归的基例\n\n\n基例，这个词我在网上除了CSDN上关于递归的文章之外没找到这个词语的解释，就离谱，不过找到英文为base case可能是翻译过来的\n\n类似数学归纳法\n证明当n取第一个值n1时命题成立\n假设当nk时命题成立，证明当n=nk+1是命题也成立\n递归是数学归纳法思维的编程体现\n\n\nn后面跟的1、k、k+1都为下标，不方便打出来就这样表示\n\n实现\ndef fact(n):    if n == 0 :        return 1    else :        return n*fact(n-1)\n\n函数+分支语句\n\n递归本身是一个函数，需要函数定义方式描述\n函数内部，采用分支语句对输入参数进行判断\n基例和链条，分别编写对应代码\n\n上例当n=5时，执行该程序计算机会分配五块内存进行运算，感觉会内存就比较浪费\n字符串反转def rvs(s):    if s == \"\"    \treturn s    else :        return rvs(s[1:])+s[0]\n\n斐波那契数列F(n) = F(n+1) + F(n-2)\ndef f(n):    if n == 1 or n == 2 :        return 1    else :        return f(n-1) + f(n-2)\n\n汉诺塔count = 0def hanoi(n, src, dst, mid):    global count    if n == 1 :         print(\"{}:{}-&gt;{}\".format(1,src,dst))        count += 1    else :        hanoi(n-1, src, mid, dst)        print(\"{}:{}-&gt;{}\".format(n,src,dst))        count += 1        hanoi(n-1, mid, dst, src)#此处距离为三个圆盘，从A放入C中，B为过度hanoi(3,\"A\",\"C\",\"B\")print(count)\n\n分形几何\n康托尔集、谢尔宾斯基三角形、门格海绵…\n龙形曲线、空间填充曲线、科赫曲线…\n函数递归的深入应用…\n\n科赫曲线绘制源代码import turtledef koch(size, n):    if n == 0:        turtle.fd(size)    else:        for angle in [0, 60, -120, 60]:           turtle.left(angle)           koch(size/3, n-1)def main():    turtle.setup(800,400)    turtle.penup()    turtle.goto(-300, -50)    turtle.pendown()    turtle.pensize(2)    koch(600,3)     # 0阶科赫曲线长度，阶数    turtle.hideturtle()main()\n\n科赫雪花绘制源代码import turtledef koch(size, n):    if n == 0:        turtle.fd(size)    else:        for angle in [0, 60, -120, 60]:           turtle.left(angle)           koch(size/3, n-1)def main():    turtle.setup(600,600)    turtle.penup()    turtle.goto(-200, 100)    turtle.pendown()    turtle.pensize(2)    level = 3      # 3阶科赫雪花，阶数    koch(400,level)         turtle.right(120)    koch(400,level)    turtle.right(120)    koch(400,level)    turtle.hideturtle()main()\n\n安装pyinstaller库(第三方库)\ncmd命令行 pip install pyinstaller\n\n使用通过在命令行使用此库命令可以将python文件生成各种系统的可执行文件\n\ncmd命令行 pyinstaller -F &lt;文件名.py&gt;\n生成的文件包含三个文件夹，其中dist文件里面的便是生成的可执行文件\n\n\n\n\n参数\n描述\n\n\n\n-h\n查看帮助\n\n\n–clean\n清理打包过程中的临时文件\n\n\n-D, –onedir\n默认值，生成dist文件夹\n\n\n-F, –onefile\n在dist文件夹中只生成独立的打包文件\n\n\n-i &lt;图标文件名.ico&gt;\n制定打包程序使用的图标(icon)文件\n\n\n举例：pyinstaller -i &lt;文件名&gt;.ico -F &lt;文件名&gt;.py\npython 的数据类型\n数值类型、字符串、元组、列表、字典、集合（不常用）\n\n可变数据类型\n\n可变数据类型：list（列表）、dict（字典）、set（集合，不常用）\n\n不可变数据类型\n\n不可变数据类型：数值类型（int、float、bool）、string（字符串）、tuple（元组）\n\n组合数据类型\n包括集合类型（集合）、序列类型（字符串、元组、列表）和映射类型（字典）\n\n集合类型集合是多个元素的无序组合\n\n集合类型与数学中的集合概念一致\n集合元素之间无序，每个元素唯一，不存在相同元素\n集合元素不可更改，不能是可变数据类型\n\n\n集合元素独一无二，如果某个元素改变后与其他元素相同，会出现错误\n\n定义\n集合用大括号{}表示，元素见用逗号分隔\n建立集合类型用{}或set()\n建立空集合类型，必须使用set()\n\nA = {\"BearKouber\", 000,(\"BearKouebr\", 000)}print(A){0, 'BearKouber', ('BearKouebr', 0)}B = set(\"BearKouber123\")print(B){'b', 'K', 'u', 'B', 'e', 'r', '2', '3', 'a', 'o', '1'}C = {\"bear\",000,\"bear\",000}print(C){0, 'bear'}\n\n六个集合操作符\n\n\n操作符及应用\n描述\n\n\n\nS|T\n返回一个新集合，包括在集合S和T中的所有元素\n\n\nS-T\n返回一个新集合，包括在集合S但不在T中的元素\n\n\nS&amp;T\n返回一个新集合，包括在同时在集合S和T中的元素\n\n\nS^T\n返回一个新集合，包括集合S和T中的非相同元素\n\n\nS&lt;=T或S&lt;T\n返回True/False，判断S和T的子集关系\n\n\nS&gt;=T或S&gt;T\n返回True/False，判断S和T的包含关系\n\n\n集合的处理方法\n\n\n操作函数或方法\n描述\n\n\n\nS.add(x)\n如果x不在集合S中,将x增加到S\n\n\nS.discard(x)\n移除S中的元素x,如果x不在集合S中,不报错\n\n\nS.remove(x)\n移除S中元素x,如果不在集合S中,产生KeyError异常\n\n\nS.clear()\n移除S中所有元素\n\n\nS.pop()\n随机返回S的一个元素,更新S,若S为空产生KeyError异常\n\n\nS.copy()\n返回集合S的一个副本\n\n\nlen(S)\n返回集合S的元素个数\n\n\nx in S\n判断S中元素x,x在集合S中,返回True,否则返回False\n\n\nx not in S\n判断S中元素x,x不在集合S中.返回True,否则返回False\n\n\nset(x)\n将其他类型变量x转为集合类型\n\n\n此处KeyError异常可以通过try来进行异常处理\n无序因为集合元素无序,所以进行集合运算的输出结果也可能无序,但是其实集合定义后是有一个顺序的只不过程序员没法利用\nA = {\"B\",\"E\",00}for item in A :    print(item,end = \"\")E0B\n\ntry和while进行集合输出A = {\"B\",\"E\",00}try:    while True:        print(A.pop(),end=\"\")except:    passE0B\n\n判断元素是否在集合中\"p\" in {\"p\",\"y\",123}True{\"p\",\"y\"} &gt;= {\"p\",\"y\",123}False\n\n利用集合元素无重复进行数据去重ls = [\"p\",\"p\",\"y\",\"y\",123]s = set(ls)\t# 可以理解为列表转集合print(s){'p', 123, 'y'}lt = list(s)print(lt)['p', 123, 'y']\n\n序列定义\n序列是具有先后关系的一组元素\n\n\n序列是一维元素向量，元素类型可以不同\n类似数学元素序列，元素序号正向递增\n元素间由序号引导，通过下标访问序列的特定元素\n\n序列是一个基本类型，其操作使用于字符串、元组、列表类型\n\n\n\n操作符及使用\n描述\n\n\n\nx + t\n连接两个序列x和t\n\n\nn * s 或 s * n\n将序列s赋值n次\n\n\nx in s\n如果x是序列s的字串，返回True，否则返回False\n\n\nx not in s\n如果x是序列s的字串，返回False，否则返回True\n\n\ns[i]\n索引，返回s中的第i个元素，i是序列的序号\n\n\ns[i:j]或s[i:j:k]\n切片，返回序列s中第i到j以k为步长的元素子序列\n\n\n取反函数跟字符串一样，可以使用s[i:j:k]令k=-1即可对序列取反\n\n\n\n函数和方法\n描述\n\n\n\nlen(s)\n返回序列s的长度\n\n\nmin(s)\n返回序列s的最小元素，s中元素需要有可比性\n\n\nmax(x)\n返回序列s的最大元素，s中元素需要有可比性\n\n\ns.index(x)或s.index(x,i,j)\n返回序列s从i开始到j位置中第一次出现元素x的位置\n\n\ns.count(x)\n返回序列s中出现x的总次数\n\n\n字符串比较字符按照比较字符序s = \"BearKouber123\"max(s)'u'\t#显然u的字母序最大\n\n元组定义\n元组是序列类型的一种扩展\n\n\n元组是一种序列类型，一旦创建就不能被修改\n使用小括号()或tuple()创建，元素间用逗号，分隔\n可以使用或不使用小括号\n\ncreature = \"cat\",\"dog\",\"tiger \",\"human\"creature('cat', 'dog', 'tiger ', 'human') #系统默认逗号分割的类型为元组类型color = (0x001100,\"bule\",creature) #此将用一个更大的元组类型将之包裹起来，详细看输出color(4352, 'bule', ('cat', 'dog', 'tiger ', 'human'))color[-1][2]'tiger'\n\nreturn返回多个值返回的值(如下面的1,2就)属于元组类型\ndef DNF():    return 1,2\n\n操作\n继承了序列全部的通用操作\n元组因为创建后不能修改，因此没有特殊操作\n使用或不使用小括号\n\n例如\ncreature = \"cat\",\"dog\",\"tiger\",\"human\"creature[::-1]('human', 'tiger', 'dog', 'cat')\n\n列表定义\n列表是序列类型的一种扩展，十分常用\n\n\n列表是一种序列类型，创建后可以随意被修改\n使用方括号[]或list()创建，元素间用逗号,分隔\n列表中个元素类型可以不同，无长度限制\n\nls = [\"cat\",\"dog\",\"tiger\",2077]ls['cat', 'dog', 'tiger', 2077]lt = ls\t\t#其实是把lt指向lslt['cat', 'dog', 'tiger', 2077]\n\n使用方括号[]或list才是真正创建了一个列表，赋值仅传递引用，相当于重新命名\n操作\n\n\n函数或方法\n描述\n\n\n\nls[i] = x\n替换列表ls第i元素为x\n\n\nls[i:j:k] = lt\n用列表lt替换ls切片后对应元素子列表\n\n\ndel ls[i]\n删除列表ls中第i元素\n\n\ndel ls[i:j:k]\n删除列表ls中第i到第j以k为步长的元素\n\n\nls += lt\n更新列表ls，将列表lt元素增加到列表ls中\n\n\nls *= n\n更新列表ls，其元素重复n次\n\n\nls.append(x)\n在列表ls最后增加一个元素x\n\n\nls.clear()\n删除列表ls中所有的元素\n\n\nls.copy()\n生产一个新列表，赋值ls中所有的元素\n\n\nls.insert(i,x)\n在列表的第i位置增加元素x\n\n\nls.pop(i)\n将列表ls中出现的第一个元素取出并删除该元素\n\n\nls.remove(x)\n将列表ls中出现的第一个元素x删除\n\n\nls.reverse()\n将列表ls中的元素反转\n\n\nls[i:j:k] = ltls[i:j:1]ls = [\"cat\",\"dog\",\"tiger\",2077]lt = [1,2,3,4,5]ls[::] = ltprint(ls)[1, 2, 3, 4, 5]\n\nls[i:j:-1]ls = [\"cat\",\"dog\",\"tiger\",2077]lt = [1,2,3,4,5]ls[::-1] = ltprint(ls)ValueError: attempt to assign sequence of size 5 to extended slice of size 4    ls = [\"cat\",\"dog\",\"tiger\",2077]lt = [1,2,3,4]ls[::-1] = ltprint(ls)[4, 3, 2, 1]\n\nls[i:j:2]ls = [\"cat\",\"dog\",\"tiger\",2077]lt = [1,2,3,4]ls[::2] = ltprint(ls)ValueError: attempt to assign sequence of size 4 to extended slice of size 2     ls = [\"cat\",\"dog\",\"tiger\",2077]lt = [1,2]ls[::2] = ltprint(ls)[1, 'dog', 2, 2077]ls = [\"cat\",\"dog\",\"tiger\",2077]lt = [1]ls[::2] = ltprint(ls)ValueError: attempt to assign sequence of size 1 to extended slice of size 2\n\nremove，pop和del方法的区别removeremove(item)方法是直接对可变序中的元素进行检索删除，返回的是删除后的列表,不返回删除值（返回None）\nlist1=[1,3,6,7,8]print(list1.remove(3)) #对列表元素进行搜索删除，而不是下表print(list1)None[1, 6, 7, 8]\n\npoppop(index)方法是对可变序列中元素下标进行检索删除，返回删除值\nlist1=[1,3,6,7,8]print(list1.pop(3))#对列表下表进行检索删除print(list1)7[1, 3, 6, 8]\n\ndeldel(list[index])方法是对可变序列中元素下边进行检索删除，不返回删除值\nlist1=[1,3,6,7,8]del list1[3] #或del(list1[3])print(list1)[1, 3, 6, 8]\n\n序列类型应用场景\n元组用于元素不改变的应用场景，更多用于固定搭配场景\n列表更加灵活，它是最常用的序列类型\n最重要作用：表示一组有序数据，进而操作它们\n\ntuple() 列表转化元组这样后续怎么操作都不会改变此组的值，进行数据保护\nls = [\"cat\",\"dog\",\"tiger\",2077]lt = tuple(ls)lt('cat', 'dog', 'tiger', 2077)\n\n\n\n\n\n\n\n\n\n"},{"title":"git拉取Github库并删除库里面某个文件","url":"/2022/09/29/git%E6%8B%89%E5%8F%96Github%E5%BA%93%E5%B9%B6%E5%88%A0%E9%99%A4%E5%BA%93%E9%87%8C%E9%9D%A2%E6%9F%90%E4%B8%AA%E6%96%87%E4%BB%B6/","content":"git拉取Github库并删除库里面某个文件1.拉取该库代码到本地git拉取过程报错\n\n$ git clone https://github.com/BearKouber/Web\nSSL certificate problem: unable to get local issuer certificate\n\n\n解决方法\n\ngit config –global http.sslVerify false\n\n2.将远程分支与本地分支进行关联\n\n\n进入拉取到本地的文件夹\n\ncd Web\n\n关联\n\ngit pull origin main\n\n查看是否连接成功\n\ngit branch -vv\n可以看到master后面蓝色部分origin/main，说明master分支已经与origin/main绑定在一起了。\n\n3.删除\n\ngit rm –cached config.js   //删除config.js文件 \ngit rm -r  –cached  config   //删除config文件夹    \n\n4.推送到远程\n\n\ngit commit -m ‘删除某个文件’    //commit提交 \ngit push //此处push时候弹出需要登录GitHub于是登录连接上了，应该是连接上才能push到github\n\n于是刷新后，GitHub库里面的文件就不见了，耶✌\n"},{"title":"页内跳转测试","url":"/2022/10/01/%E9%A1%B5%E5%86%85%E8%B7%B3%E8%BD%AC%E6%B5%8B%E8%AF%95/","content":"标题一标题二标题三标题四下面为其他标题\n标题1.1head1.2head1.3head1.4head1.5中间为分割线分割线分割线分割线分割线分割线分割线分割线\n\n标题一\n这是标题一\n这是标题一\n这是标题一\n这是标题一\n这是标题一\n这是标题一\n标题二\n这是标题二\n这是标题二\n这是标题二\n这是标题二\n这是标题二\n标题三\n这是标题三\n这是标题三\n这是标题三\n这是标题三\n这是标题三\n这是标题三\n标题四\n这是标题四\n这是标题四\n这是标题四\n这是标题四\n这是标题四\n标题1.1\n这是标题1.1\n这是标题1.1\n这是标题1.1\n这是标题1.1\n这是标题1.1\n这是标题1.1\n标题1.2\n这是标题1.2\n这是标题1.2\n这是标题1.2\n这是标题1.2\n这是标题1.2\n标题1.3\n这是标题1.3\n这是标题1.3\n这是标题1.3\n这是标题1.3\n这是标题1.3\n标题1.4\n这是标题1.4\n这是标题1.4\n这是标题1.4\n这是标题1.4\n这是标题1.4"}]