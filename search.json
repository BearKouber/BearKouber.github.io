[{"title":"Java学习笔记(1)","url":"/2021/12/28/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/","content":"BearKouber的Java学习记录简单的笔记\n字符型（char）Java中是允许保存有中文的。\nchar最大的优势也就在于中文处理。\n之所以在java语言里面可以使用char进行中文数据的保存，是因为java使用的是unicode这种十六进制的编码,这种编码的主要特点是可以包括任意的文字内容，所以使得程序开发更加的简单。\n布尔型布尔主要描述的是一种逻辑的处理结果。\nJava的布尔类型的取值范围只有两个数据：true，false。\n定义布尔型数据\nboolean flag = true;\n\nString字符串字符串之间可以通过 + 来进行连接。\nString str = &quot;hello&quot;;str = str + &quot; world&quot;;str += &quot; !!!&quot;;\n\n输出的str为hello world !!!\n在Java语言里面，数据范围大的数据类型与数据范围小的数据类型进行计算的时候，所有范围小的数据类型自动转型为范围大的数据类型，但是如果此时有String字符串了，则所有的类型无条件先变为String,如果有“+”表示的就是字符串连接。\ndouble x = 20.1;int y = 10;String str = &quot;计算结果：&quot; + x + y;\n\n输出的str为计算结果：20.110\n在描述字符串的时候也可以使用转义字符进行一些处理，例如:TAB ( t)、”(&quot;)、’(&#39;)、换行、( \\n)、(\\)。\n位运算·&amp;和|两个运算符可以进行位运算与逻辑运算；\n |-在进行逻辑运算的时候所有的判断条件都要执行；\n |-在进行位运算的时候只是针对于当前的数据进行与和或处理；\n· 在逻辑运算上还可以使用&amp;&amp;、||；\n |-&amp;&amp;:在若干个条件判断的时候，如果前面的条件返回了false,后续所有的条件都不再判断最终的结果就是false;\n |-||：在若干个条件判断的时候，如果前面的条件返回了true,后续条件不再执行，最终就是true.\n条件运算符条件运算符也被称为三元运算符。该运算符有3个操作数，并且需要判断布尔表达式的值。该运算符的主要是决定哪个值应该赋值给变量。\n//variable x = (expression) ? value if true : value if falsepublic class Test &#123;   public static void main(String[] args)&#123;      int a , b;      a = 10;      // 如果 a 等于 1 成立，则设置 b 为 20，否则为 30      b = (a == 1) ? 20 : 30;      System.out.println( &quot;Value of b is : &quot; +  b );       // 如果 a 等于 10 成立，则设置 b 为 20，否则为 30      b = (a == 10) ? 20 : 30;      System.out.println( &quot;Value of b is : &quot; + b );   &#125;&#125;\n\n运行结果如下\nValue of b is : 30Value of b is : 20\n\ninstanceof 运算符/*该运算符用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）。\n( Object reference variable ) instanceof  (class/interface type)\n\n如果运算符左侧变量所指的对象，是操作符右侧类或接口(class/interface)的一个对象，那么结果为真。\nString name = &quot;James&quot;;boolean result = name instanceof String; // 由于 name 是 String 类型，所以返回真\n\nJava运算符优先级\n\n\n类别\n操作符\n关联性\n\n\n\n后缀\n() [] . (点操作符)\n左到右\n\n\n一元\nexpr++ expr–\n从左到右\n\n\n一元\n++expr –expr + - ～ ！\n从右到左\n\n\n乘性\n* /％\n左到右\n\n\n加性\n+ -\n左到右\n\n\n移位\n&gt;&gt; &gt;&gt;&gt;  &lt;&lt;\n左到右\n\n\n关系\n&gt; &gt;= &lt; &lt;=\n左到右\n\n\n相等\n== !=\n左到右\n\n\n按位与\n＆\n左到右\n\n\n按位异或\n^\n左到右\n\n\n按位或\n|\n左到右\n\n\n逻辑与\n&amp;&amp;\n左到右\n\n\n逻辑或\n| |\n左到右\n\n\n条件\n？：\n从右到左\n\n\n赋值\n= + = - = * = / =％= &gt;&gt; = &lt;&lt; =＆= ^ = | =\n从右到左\n\n\n逗号\n，\n左到右\n\n\nfor循环for(初始化; 布尔表达式; 更新) &#123;    //代码语句&#125;\n\n虽然所有循环结构都可以用 while 或者 do…while表示，但 Java 提供了另一种语句 —— for 循环，使一些循环结构变得更加简单。\nfor循环执行的次数是在执行前就确定的。语法格式如下：\nfor(初始化; 布尔表达式; 更新) {    //代码语句 }\n关于 for 循环有以下几点说明：\n\n最先执行初始化步骤。可以声明一种类型，但可初始化一个或多个循环控制变量，也可以是空语句。\n然后，检测布尔表达式的值。如果为 true，循环体被执行。如果为false，循环终止，开始执行循环体后面的语句。\n执行一次循环后，更新循环控制变量。\n再次检测布尔表达式。循环执行上面的过程。\n\njava增强for循环Java5 引入了一种主要用于数组的增强型 for 循环。\nJava 增强 for 循环语法格式如下:\nfor(声明语句 : 表达式) {   //代码句子 }\n声明语句：声明新的局部变量，该变量的类型必须和数组元素的类型匹配。其作用域限定在循环语句块，其值与此时数组元素的值相等。\n表达式：表达式是要访问的数组名，或者是返回值为数组的方法。\n实例Test.java 文件代码：public class Test &#123;   public static void main(String args[])&#123;      int [] numbers = &#123;10, 20, 30, 40, 50&#125;;       for(int x : numbers )&#123;         System.out.print( x );         System.out.print(&quot;,&quot;);      &#125;      System.out.print(&quot;\\n&quot;);      String [] names =&#123;&quot;James&quot;, &quot;Larry&quot;, &quot;Tom&quot;, &quot;Lacy&quot;&#125;;      for( String name : names ) &#123;         System.out.print( name );         System.out.print(&quot;,&quot;);      &#125;   &#125;&#125;\n\n\n\n以上实例编译运行结果如下：\n10,20,30,40,50,James,Larry,Tom,Lacy,\n\nbreak 关键字break 主要用在循环语句或者 switch 语句中，用来跳出整个语句块。\nbreak 跳出最里层的循环，并且继续执行该循环下面的语句。\ncontinue 关键字continue 适用于任何循环控制结构中。作用是让程序立刻跳转到下一次循环的迭代。\n在 for 循环中，continue 语句使程序立即跳转到更新语句。\n在 while 或者 do…while 循环中，程序立即跳转到布尔表达式的判断语句。\nJava语言支持一些特殊的转义字符序列。\n\n\n符号\n字符含义\n\n\n\n\\n\n换行 (0x0a)\n\n\n\\r\n回车 (0x0d)\n\n\n\\f\n换页符(0x0c)\n\n\n\\b\n退格 (0x08)\n\n\n\\0\n空字符 (0x0)\n\n\n\\s\n空格 (0x20)\n\n\n\\t\n制表符\n\n\n&quot;\n双引号\n\n\n&#39;\n单引号\n\n\n\\\n反斜杠\n\n\n\\ddd\n八进制字符 (ddd)\n\n\n\\uxxxx\n16进制Unicode字符 (xxxx)\n\n\n类声明对象\n声明并实例化对象：类名称 对象名称 = new 类名称();\n\n分步骤完成：\n\n声明对象：类名称 对象名称 = null；\n\n实例化对象：对象名称 = new 类名称()。\n\n\n\n\n类的调用\n调用类中的属性：实例化对象.成员属性；\n\n调用类中的方法：实例化对象.方法名称()。\n\n\nclass Person&#123;    String name;    int age;    public void tell()&#123;        System.out.println(&quot;姓名:&quot;+ name +&quot;\\n&quot;+&quot;年龄：&quot;+ age);    &#125;&#125;public class Demo &#123;    public static void main(String args[]) &#123;        Person per = new Person();        per.age=18;        per.name = &quot;kouber&quot;;        per.tell();    &#125;&#125;输出结果：姓名:kouber年龄：18\n\n使用this调用方法除了调用属性之外，this也可以实现方法的调用，但是对于方法的调用就必须考虑构造与普通方法\n\n构造方法调用（this()）;使用关键字new实例化对象的时候才会调用构造方法；\n普通方法调用（this.方法名称()）；实例化对象产生之后就可以调用普通方法\n\nthis调用本类方法\n构造方法必须在实例化新对象的时候调用，所以“this()”的语句只允许放在构造方法的首行\n在构造方法中能调用普通方法，反过来普通方法不能调用构造方法；this()不能在普通方法中使用\n构造方法互相调用时请保留有程序的出口，别形成死循环；\n\nstaticstatic属性可以有类名称直接调用类名称.(static)属性 = （赋值）n\nstatic属性虽然定义在类之中，但是其并不受到类实例化对象的控制。\nstatic属性可以在没有实例化对象的时候使用，非static属性必须在实例化对象产生之后才可以使用\n\n考虑到公共信息储存的时候才会使用到static属性\n\nstatic方法和非static方法调用上的限制\nstatic方法只允许调用static属性或static方法\n非static方法允许调用static属性或static方法\n\n所有的static定义的属性和方法都可以在没有实例化对象的前提下使用，而所有的非static定义的属性和方法必须要有实例化对象的情况下才可以使用\n在static方法中调用非static方法可以通过对象来调用\npublic class Demo &#123;    public static void main(String args[]) &#123;        new Demo().print() ; // 此处Demo后需要加上括号    &#125;    public void print() &#123;        System.out.println(&quot;www.pintia.cn&quot;) ;    &#125;&#125;\n\nstatic定义的方法或者是属性都不是在代码编写之初所需要考虑的内容，只有在回避实例化对象调用并且描述公共属性的情况下才会考虑static定义的方法或者是属性。\nJava程序逻辑控制：Swith开关语句与c语言不同的是Java里面的Switch语句能判断字符串(String)。\n简单Java类核心开发结构如下：\n\n类名称一定要有意义，可以明确的描述某一类事物；\n类之中的所有属性都必须使用private进行封装，同时封装后的属性必须要提供有setter、getter方法；\n类之中可以提供有无数多个构造方法，但是必须要保留有无参构造方法\n类之中不允许出现任何的输出语句，所有内容的获取必须返回\n【非必须】可以提供有一个获取对象详细信息的方法，暂时将此方法名称定义为getInfo()\n\n新手代码练习要求以后打简单java类100%正确率\nclass Dept &#123;    private long deptno ;    private String dname ;    private String loc;    public Dept() &#123;&#125;    public Dept(long deptno,String dname,String loc) &#123;        this.deptno = deptno ;        this.dname = dname ;        this.loc = loc ;     &#125;    public String getInfo() &#123;        return &quot;【部门信息】部门编号：&quot; + this.deptno + &quot;、部门名称 &quot; + this.dname + &quot;、部门位置 ：&quot; + this.loc ;    &#125;    public void setDeptno(long deptno) &#123;        this.deptno = deptno;    &#125;    public void setDname(String dname) &#123;        this.dname = dname ;    &#125;    public void setLoc(String loc) &#123;        this.loc = loc ;    &#125;&#125;public class Demo &#123;    public static void main(String args[]) &#123;        Dept dept = new Dept(10,&quot;技术部&quot;,&quot;北京&quot;);        System.out.println(dept.getInfo());    &#125;&#125;\n\n关系运算符所有的关系运算返回的判断结果都是布尔型数据\n尝试使用int型数据接收结果报错boolean无法转换为int\n构造块构造块会优先于构造方法执行，并且每一次实例化新对象的时候都会调用构造快中的代码。\n静态代码块会优先与构造块执行，但有多个实例化对象出现时，静态代码块只会执行一次。\n静态代码块的主要目的是静态属性的初始化。\n静态代码块比主方法先执行\npublic class Demo &#123;    static &#123;   \t\tSystem.out.println(&quot;静态代码块：最高优先级&quot;) ;       &#125;    public static void main(String args[]) &#123;        System.out.println(&quot;主方法代码块：执行次于静态代码块&quot;) ;    &#125;&#125;执行结果：静态代码块：最高优先级主方法代码块：执行次于静态代码块\n\n\n\n构造方法与匿名对象构造方法：对类的对象的属性进行初始化可以通过构造方法实现实例化对象中的属性初始化处理\nJava程序里面构造方法的定义要求如下：\n\n构造方法名称必须与类名称一致\n构造方法不允许设置任何的返回值类型；即没有返回值定义\n构造方法是在使用关键字new实例化对象的时候自动调用的\n\n类中一定会有一个构造方法，如果没有明确定义，系统会自动创建一个无参的构造方法\n构造方法如何使用class Message &#123;    private String title ;    public Message (String t)&#123;//定义有参构造        title = t;    &#125;     public String getTitle()&#123;        return title;    &#125;    public void setTitle(String t) &#123;        title = t;    &#125;&#125;class Person &#123;\t//定义一个类    private String name ;    private int age;    public Person (Message msg,int a)&#123; //定义有参构造        name = msg.getTitle();\t//为类中的属性赋值（初始化）        age = a;\t//为类中的属性赋值（初始化）    &#125;    public Message getInfo() &#123;        return new Message(name + &quot; : &quot; + age);    &#125;    public void tell() &#123;        System.out.println(&quot;姓名：&quot;+ name +&quot;、年龄：&quot; + age);   \t&#125;&#125;public class Demo &#123; //主类    public static void main(String args[])&#123;        Message msg = new Message(&quot;mldn&quot;);        Person per = new Person(msg,20);        msg = per.getInfo();        System.out.println(msg.getTitle());    &#125;&#125;运行结果：mldn : 20\n\n匿名对象的使用用完直接扔\nclass Person &#123;\t//定义一个类    private String name ;    private int age;    public Person (String name,int a)&#123; //定义有参构造        this.name = name;\t//为类中的属性赋值（初始化）        age = a;\t//为类中的属性赋值（初始化）    &#125;    public void tell() &#123;        System.out.println(&quot;姓名：&quot;+ name +&quot;、年龄：&quot; + age);   \t&#125;&#125;public class Demo&#123;    public static void main(String args[])&#123;        new Person(&quot;Kouber&quot;，18).tell;//进行方法的调用    &#125;&#125;运行结果：姓名：Kouber、年龄：18\n\n此对象没有引用，使用后会变成垃圾，所有的垃圾将被GC进行回收与释放\n方法重载当方法名称相同，参数的类型或个数不同的时候就称为方法重载。\npublic class JavaDemo&#123;    public static void main(String args[])&#123;        int resultA = sum(10,20);        int resultB = sum(10,20,30);        double resultC = sum(10.2,20.3);        System.out.println(&quot;resultA=&quot;+resultA);        System.out.println(&quot;resultB=&quot;+resultB);        System.out.println(&quot;resultC=&quot;+resultC);    &#125;    public static int sum(int x,int y)&#123;        return x + y;    &#125;    public static int sum(int x,int y,int z)&#123;        return x + y + z;    &#125;    public static double sum(double x,double y)&#123;        return x + y ;    &#125;&#125;\n\n\n\n可以发现同一个方法名称但是可以根据调用时传递的不同参数的类型或个数实现不同方法体的调用，这样就实现了方法重载的定义。\n数组定义语法\n数组的动态初始化，初始化之后数组每一个元素的保存内容为其对应数据类型的默认值\n声明并初始化数组：\n数据类型 数组名称 [] = new 数据类型 [长度] ；\n数据类型 [] 数组名称 = new 数据类型 [长度] ；\n\n\n\n\n\npublic class Demo &#123;    public static void main (String args[]) &#123;        int a [] = new int [10] ;        int [] b = new int [10] ;    &#125;&#125;\n\n\n\n\n数组的静态初始化：在数组定义的时候就为其设置好了里面的内容：\n简化格式：数据类型 数组名称 [] = {数据类型 1，数据类型 2，数据类型 3，···};\n完整格式：数据类型 数组名称 [] = new 数据类型 [] {数据类型 1，数据类型 2，数据类型 3，···}; (黑体部分：匿名数组)\n老师强烈建议用完整格式进行数组的初始化\n\n\n\n当使用数组下标超出数组范围时候，程序编译会有此报错\nArrayIndexOutOfBoundsException\n意味数组越界\n求数组长度： 数组名.lengthpublic class Demo &#123;    public static void main(String args[]) &#123;        int [] data = new int [3] ;        System.out.print(data.length) ;    &#125;&#125;结果输出：3\n\n增强型for循环：foreach（迭代输出）利用foreach的语法结构可以直接自动获取数组中的每一个元素，避免下标访问\nfor(数据类型 变量 : 数组 | 集合) &#123;&#125;\n可以自动将数组中的每一个元素的内容取出保存在变量里面，这样就能直接通过变量获取内容避免使用下标\npublic class Demo &#123;\tpublic static void main(String args[]) &#123;\t\tint [] data = new int [] &#123;1,2,3,4,5&#125; ;\t\tfor (int temp : data) &#123;\t\t\tSystem.out.print(temp) ;\t\t&#125;\t&#125;&#125;输出结果：12345\n\n引用数据类型内存分析（数组）引用数据类型：必须在为之开辟了堆内存空间之后才可以使用。\npublic class Demo &#123;    public static void main(String args[]) &#123;        int [] data = new int [] &#123;10,20,30&#125; ; //静态初始化        int [] temp = data ; //引用传递        temp [0] = 100 ;        for (int x = 0 ; x &lt; data.length ; x++) &#123;            System.out.print(data[x] ) ;        &#125;    &#125;&#125;输出结果：100 20 30 \n\nnew的出现创建了新的堆内存空间，而data储存在栈内存中（data中的数据储存在堆内存中，data在栈中储存的是他的数据的地址即堆内存的地址），temp引用传递即为另一栈内存指向了data指向的堆内存地址即data的数据地址，从而改动temp数据就会改动data的数据。\n两者的数据本质上是同一个堆内存里面的数据\n由于数组属于引用类型，所以一定要为其开辟堆内存空间之后才可以使用，如果现在使用了未开辟空间的数组，会出现NullPointerException（数组）\n例：\npublic class Demo &#123;    public static void main &#123;        int [] data = null ;        System.out.print(data[0]) ;    &#125;&#125;正常编译但是运行会出现**NullPointerException**报错\n\n\n\n因此：数组必须提供有实例化对象才可与使用数组的操作形式进行数组的操作\n方法传递数组public class Demo&#123;    public static void main(String args[])&#123;        int data [] = initArray();        printArray(data);//传递数组    &#125;    public static int [] initArray() &#123;        int arr [] = new int [] &#123;1,2,3,4,5&#125;;        return arr;//返回一个数组    &#125;    //要求接受一个int型的数组    public static void printArray(int temp []) &#123;        for(int x = 0 ; x &lt; temp.length ; x++)&#123;            System.out.print(temp[x]、) ;        &#125;    &#125;&#125;输出结果：1、2、3、4、5、\n\n如果程序代码都是通过主方法完成的，就不符合面向对象的设计结构，最好是设计一个类来实现此程序代码\n类中没有属性存在的意义，就没有必要定义普通方法了，普通方法还需要实例化对象，因此直接定义类（静态）方法就行。\n如下将一些操作和计算封装从而使主类更加简便\nclass ArrayUtil &#123; // 是一个操作工具的类    private int sum ;//保存总和    private double avg ;//保存平均值    private int max ;//保存最大值    private int min ;//保存最小值    public ArrayUtil(int data[]) &#123;//进行数组计算        this.max = data[0] ;//假设第一位最大        this.min = data[0] ;//假设第一位最小        for(int x = 0 ; x &lt; data.length ; x++) &#123;//max、min地位改变            if(data[x] &gt; max) &#123;                this.max = data[x];            &#125;            if(data[x] &lt; min) &#123;                this.min = data[x] ;            &#125;            this.sum += data[x] ;        &#125;        this.avg = sum / data.length ;    &#125;    public int getSum() &#123;        return this.sum;    &#125;    public double getAvg() &#123;        return this.avg;    &#125;    public int getMax() &#123;        return this.max;    &#125;    public int getMin() &#123;        return this.min;    &#125;&#125;public class Demo&#123;    public static void main(String args[]) &#123;        int data [] = new int [] &#123;1,2,3,4,5&#125; ;        ArrayUtil util = new ArrayUtil(data) ;        System.out.println(&quot;数组总和：&quot;+util.getSum()) ;        System.out.println(&quot;数组平均值：&quot;+util.getAvg()) ;        System.out.println(&quot;数组最大值：&quot;+util.getMax()) ;        System.out.println(&quot;数组最小值：&quot;+util.getMin()) ;    &#125;&#125;输出结果：数组总和：15数组平均值：3.0数组最大值：5数组最小值：1\n\n\n\n\n\n二维数组定义语法\n数组的动态初始化：\n\n数据类型 数组名称 [][] [] [] = new 数据类型 [行个数] [列个数] ;\n\n\n数组的静态初始化：\n\n数据类型 数组名称 [] [] = new 数据类型 [] [] { {数据，数据，···},{数据，数据，···} } ;\n\n\n\npublic class Demo &#123;    public static void main(String args[]) &#123;        int [] [] data = new int [] [] &#123; &#123;1,2,3,4,5&#125;,&#123;1,2,3&#125;,&#123;5,6,7,8&#125; &#125; ;        for(int x = 0 ; x &lt; data.length ; x ++) &#123; //这里的data.length = 3             for(int y = 0 ;y &lt; data[x].length ; y ++)&#123;                System.out.println(&quot;data[&quot;+x+&quot;][&quot;+y+&quot;]=&quot;+data[x][y]) ;            &#125;            System.out.println() ;        &#125;    &#125;&#125;输出结果：data[0][0]=1data[0][1]=2data[0][2]=3data[0][3]=4data[0][4]=5data[1][0]=1data[1][1]=2data[1][2]=3data[2][0]=5data[2][1]=6data[2][2]=7data[2][3]=8\n\n使用foreach输出该二维数组\npublic class Demo &#123;    public static void main(String args[]) &#123;        int [] [] data = new int [] [] &#123; &#123;1,2,3,4,5&#125;,&#123;1,2,3&#125;,&#123;5,6,7,8&#125; &#125; ;        for(int temp [] : data) &#123; //这里的data.length = 3             for(int num : temp)&#123;                System.out.print(num + &quot;、&quot;) ;            &#125;            System.out.println() ;        &#125;    &#125;&#125;输出结果：1、2、3、4、5、1、2、3、5、6、7、8、\n\n通过foreach可以看出，二维数组就是数组的嵌套使用\n方法可变参数class ArrayUtil &#123;    public static int sum(int [] data) &#123;        int sum = 0 ;        for(int temp : data) &#123;            sum += temp ;        &#125;        return sum ;    &#125;&#125;public class Demo&#123;\tpublic static void main(String args[]) &#123;        System.out.print(ArrayUtil.sum(new int [] &#123;1,2,3&#125;)) ;    \t//上面如果是这样(new [] int &#123;1,2,3&#125;) ;则会出现报错        //错误: 需要&lt;标识符&gt; System.out.println(ArrayUtil.sum(new^(此处标出错误)[] int &#123;1,2,3&#125;)) ;    &#125;&#125;输出结果：6\n\nclass ArrayUtil &#123;    public static int sum(int ... data) &#123;        int sum = 0 ;        for(int temp : data) &#123;            sum += temp ;        &#125;        return sum ;    &#125;&#125;public class Demo&#123;\tpublic static void main(String args[]) &#123;        System.out.printl(ArrayUtil.sum(1，2，3)) ;    &#125;&#125;输出结果：6\n\n可变参数的最大作用在于，在以后进行一些程序设计或者开发者调用的时候，利用此种形式避免数组的传递操作。\n可变参数的本质还是数组。\n数组相关类库数组排序：*java.until.Arrays.sort(数组名称);*（升序）\n数组拷贝：System.arraycopy(原数组，原数组开始点，目标数组，目标数组开始点，拷贝长度);\n堆栈内存\n堆内存：保存的是对象的具体信息，在程序之中堆内存空间的开辟是通过new完成的。\n栈内存：保存的是一块对内存的地址，即：通过地址找到堆内存，然后找到对象内容\n\n对象必须实例化之后才能使用否则无法使用\njava输入方式一、从键盘获取不限制长度的数组import java.util.Scanner;public class Demo &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;请输入几个数并用逗号隔开:&quot;);        Scanner sc = new Scanner(System.in);//从键盘接收数据        String str = sc.next().toString();//next()方式接收字符串        System.out.println(str);        String [] arr  = str.split(&quot;.&quot;);        for(int j = 0; j&lt;arr.length;j++) &#123;          System.out.print(arr[j]+&quot; &quot;);        &#125;    &#125;&#125;\n\n二、从键盘获取限制长度的数组import java.util.Scanner;public class InputArrayLimitLength &#123;\tpublic static void main(String[] args) &#123;\t\tScanner scanner = new Scanner(System.in);\t\tint n = scanner.nextInt();\t\tSystem.out.println(&quot;请输入&quot;+n+&quot;个数：&quot;);\t\tScanner sc = new Scanner(System.in);\t\tint[] b=new int[n];\t\tfor(int i=0;i&lt;b.length;i++)&#123;\t\t\tb[i]=sc.nextInt();\t\t\tSystem.out.print(&quot; &quot; + b[i]);\t\t&#125;\t&#125;&#125;\n\n\n\n"},{"title":"Iostream Inputoutput (C++)","url":"/2022/01/03/Iostream-Inputoutput-C/","content":"Iostream Input/output (C++)文章取自[维基百科-Iostream Inputoutput (C++)](iostream - 维基百科，自由的百科全书 (wikipedia.org))\n（重定向⾃ Cout）\niostream是C++中⽤于数据的流式输⼊与输出的头⽂档，属于C++标准程序库的⼀部分。\niostream 为 Input/Output Stream 的缩写，即是输⼊/输出流。「流」是⼀连串从I/O设备读写的 字符。\n概述流输入输出库中的大部分类都是模板类，可以适用于不同的字符类型或操作函数（如字符比较）。常用的一些字符类型的流输入输出已经用[typedef]定义了相应的模板特化实例。\n例如，basic_fstream&lt;CharT,Traits&gt;是文件流输入输出的实现的模板类。它的一个特化实例：fstream是basic_fstream&lt;char,char_traits&lt;char&gt;&gt;的类型别名，换句话说，这是basic_fstream的字符类型为char使用默认字符操作集的特化实例。\n流输入输出库中的类可分为两类。一是定义了界面的抽象，适用于任何流类型，无论是文件流、内存缓存区流或者网络socket流。二是对具体数据源与数据汇（sink）的流的实现。C++标准库仅实现了文件流与内存缓冲区流。\n流输入输出库中的类依据是否实现底层或高层操作可分为两类。实现了底层操作的类称作流缓冲区（stream buffer），处理没有任何格式化功能的字符。这些类极少被编程者直接使用。实现高层操作的类称作流，并提供了不同的格式化能力，是构建于流缓冲区之上的。\n下表列出了流输入输出库的所有类的分类：\n\n\n\nClass\n解释\nTypedefs\n\n\n\nStream buffers (底层功能)\n\n\n\n\nbasic_streambuf\n提供了底层的输入输出界面，被具体的数据源与汇实现。罕用\nstreambuf - 字符类型char``wstreambuf - 字符类型wchar_t\n\n\nbasic_filebuf\n提供了文件流的底层的输入输出界面，被具体的数据源与汇实现。罕用\nfilebuf - 字符类型 char``wfilebuf -字符类型 wchar_t\n\n\nbasic_stringbuf\n提供了字符文件流的底层的输入输出界面，被具体的数据源与汇实现。罕用\nstringbuf - 字符类型char``wstringbuf - 字符类型wchar_t\n\n\nSupport classes\n\n\n\n\nios_base\n管理格式化信息与异常状态\n不适用\n\n\nbasic_ios\n管理流缓冲区\nios - 字符类型char``wios - 字符类型wchar_t\n\n\nInput streams buffers (高层功能)\n\n\n\n\nbasic_istream\n包装一个抽象流缓冲区并提供高层输入界面，如格式化能力\nistream - 字符类型 char``wistream - 字符类型wchar_t\n\n\nbasic_ifstream\n包装一个文件流缓冲区并提供高层输入界面，如打开关闭流\nifstream - 字符类型char``wifstream - 字符类型wchar_t\n\n\nbasic_istringstream\n包装一个字符串流缓冲区并提供高层输入界面，如访问基础字符串\nistringstream - 字符类型char``wistringstream - 字符类型wchar_t\n\n\nOutput streams buffers (高层功能)\n\n\n\n\nbasic_ostream\n包装一个抽象流缓冲区并提供高层输出界面，如格式化能力\nostream - 字符类型char``wostream - 字符类型wchar_t\n\n\nbasic_ofstream\n包装一个文件流缓冲区并提供高层输出界面，如打开关闭流\nofstream - 字符类型char``wofstream - 字符类型wchar_t\n\n\nbasic_ostringstream\n包装一个字符串流缓冲区并提供高层输出界面，如访问基础字符串\nostringstream - 字符类型char``wostringstream - 字符类型wchar_t\n\n\nInput/output streams buffers (高层功能)\n\n\n\n\nbasic_iostream\n包装一个抽象流缓冲区并提供高层输入输出界面，如格式化能力\niostream - 字符类型char``wiostream - 字符类型wchar_t\n\n\nbasic_fstream\n包装一个文件流输入输出缓冲区，并提供高层输入输出界面，如打开关闭文件\nfstream - 字符类型char``wfstream - 字符类型wchar_t\n\n\nbasic_stringstream\n包装一个字符串流输入输出缓冲区，并提供高层输入输出界面，如访问基础字符串\nstringstream - 字符类型char``wstringstream - 字符类型wchar_t\n\n\n头文件\n&lt;ios&gt;包含着ios_base与basic_ios的类的定义，负责信息格式化与关联的流缓冲区。\n&lt;istream&gt;包含了basic_istream类模板定义，实现了格式化输入\n&lt;ostream&gt;包含了basic_ostream类模板定义，实现了格式化输出\n&lt;iostream&gt;包含了basic_iostream类模板定义，实现格式化输入输出\n&lt;fstream&gt;包含了basic_ifstream, basic_ofstream与basic_fstream类模板定义，实现格式化文件流的格式化输入、输出\n&lt;sstream&gt;包含了basic_istringstream, basic_ostringstream与basic_stringstream 类模板定义，实现格式化字符串流的输入输出\n&lt;iomanip&gt;包含了格式化manipulator\n&lt;iosfwd&gt;包含了所有的流输入输出库的前向声明（forward declaration）\n\n支持类ios_base与basic_ios是两个类处理底层比特流。ios_base存储格式化信息与流的状态。basic_ios管理关联的流缓冲区。basic_ios通常以特化实例ios与wios出现。basic_ios与ios_base很少被程序员直接使用。通常，它们的功能通过其它派生的类，如iostream。\nTypedefs\n\n\n名字\n描述\n\n\n\nios\nbasic_ios的char类型特化\n\n\nwios\nbasic_ios的wchar_t类型特化\n\n\nstreamoff\n支持内部操作\n\n\nstreampos\n保存缓冲器指针或文件指针的当前位置\n\n\nwstreampos\n保存宽字符版的缓冲器指针或文件指针的当前位置\n\n\nstreamsize\n流的尺寸\n\n\n格式化操纵符（manipulator）\n\n\n名字\n描述\n\n\n\nboolalpha / noboolalpha\n指示流中的bool类型变量是否以true或false，还是以0或1形式出现\n\n\nskipws / noskipws\n指示输入操作时空白符是否被跳过\n\n\nshowbase / noshowbase\n指示数的基数记数标志是否显示\n\n\nshowpoint / noshowpoint\n指示当浮点数小数部分为0时，是否显示小数部分\n\n\nshowpos / noshowpos\n指示对于正数是否显示+符号\n\n\nunitbuf / nounitbuf\n指示输出是否被缓冲\n\n\nuppercase / nouppercase\n指示在16进制整数或浮点数输出时是否使用大写字符\n\n\nleft / right / internal\n指出对齐方式\n\n\ndec / oct/ hex\n指示显示整数时的记数法\n\n\nfixed / scientific/ hexfloat([C++11] / defaultfloat(C++11)\n指示浮点数显示时的记数法\n\n\n输入/输出流iostream头文件定义了输入输出流对象：cin, cout, cerr, **clog分别为标准输入、输出、错误（无缓冲）、簿记（有缓冲）的流对象。都属于std**。\nostream对象**cout属于ostream类型，重载了左移位算符。cout左移位算符的运算结果为cout自身，这使得连续的左位移操作输出一串数据成为可能。cerr与clog对象是ostream**类型。\nistream对象**cin是istream**类型，重载了右位移算符。\n输入设备是按照行来把数据移入流输入缓冲区。也就是说，键盘输入数据时，只有按了换行键，这一行数据才进入缓冲区，可以读取。\n表达式cin &gt;&gt; ival从标准输入读入一个值。有两种情况会使一个istream对象的bool转型为false：读到[EOF]（文件结束标志）或遇到一个无效的值（输入流进入fail状态）。可以用该istream对象的成员函数good()来测试，或者直接(bool)cin来测试。\nistream对象的bool转型为false的情况下，此后的所有读入动作都是无操作（nop）。直到调用istream对象的成员函数clear()来清除该对象的内部状态。\n缺省情况下，输入操作符丢弃空白符、空格符、制表符、换行符以及回车。如果希望读入上述字符，或读入原始的输入数据，一种方法是使用istream的get()成员函数来读取一个字符，另一种方法是使用istream的getline()成员函数来读取多个字符。istream的read(char* addr, streamsize size)函数从输入流中提取size个连续的字节，并将其放在地址从addr开始的内存中。istream成员函数gcount()返回由最后的get()、getline()、read()调用实际提取的字符数。\n输入流有三个函数来测试流状态：即bad(), fail()和eof()。ignore()用来抛掉制定个数的缓冲区中的字节。\n其它的istream成员函数：putback( char c ) 将字符放回iostream；unget()往回重置“下一个”istream项；peek()返回下一个字符或EOF，但不要提取出来 。\n输出格式化方法（函数）\n\n\nwidth(int x)\n下一个输出的最小字符数目\n\n\n\nfill(char x)\n填充字符\n\n\nprecision(int x)\n设置浮点数的有效数字的位数\n\n\n操纵符（manipulator）操纵符（manipulator）是使用&lt;&lt;或&gt;&gt;算子修改流的对象.\n\n\n\nendl\n“end line”: 流中插入换行符并刷新（flush）流的输出缓冲.\n\n\n\nends\n“end string”: 向流中插入空字符（null character）并刷新（flush）流的输出缓冲.\n\n\nflush\n强迫流的输出缓冲写出到输出设备.\n\n\nws\n导致输入流吃掉空白（whitespace）\n\n\nshowpoint\n指示流要显示小数点与一些数字0\n\n\n头文件中iomanip还定义了一些manipulators。\n批评某些环境下并不提供共享版本的C++库。导致程序要静态编译入C++标准库，使得程序的尺寸变大。\n示例使用[C++]写成的 [Hello World] 程序如下所示:\n#include &lt;iostream&gt;using namespace std;int main()&#123;    cout &lt;&lt; &quot;Hello, world!&quot; &lt;&lt; endl;    return 0;&#125;\n\n在这段代码中，文件 iostream 中声明了[程序]所要输入和输出操作的有关信息。\n下述代码创建一个文件’file.txt’并写入文本’Hello World’：\n#include &lt;fstream&gt;int main()&#123;    std::ofstream file;// can be merged to std::ofstream file(&quot;file.txt&quot;);    file.open(&quot;file.txt&quot;);    file &lt;&lt; &quot;Hello world!\\n&quot;;    file.close();// is not necessary because the destructor closes the open file by default    return 0;&#125;\n"},{"title":"Java学习笔记(2)","url":"/2022/01/04/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2/","content":"BearKouber的Java学习记录简单的笔记\n引用传递实际应用类关联结构代码链class Car &#123;    private String name ;    private double price ;    private Person person ;//一辆车属于一个人    public Car(String name,double price) &#123;        this.name = name ;        this.price = price ;    &#125;    public void setPerson(Person person) &#123;        this.person = person ;    &#125;    public Person getPerson() &#123;        return this.person ;     &#125;    public String getInfo() &#123;        return &quot;汽车品牌号&quot; + this.name + &quot;、汽车价格:&quot; + this.price ;    &#125;&#125;class Person &#123;    private String name ;    private int age ;    private Car car ;//一个人有一辆车    public Person(String name,int age) &#123;        this.name = name ;        this.age = age ;    &#125;    public void setCar(Car car) &#123;        this.car = car ;    &#125;    public Car getCar() &#123;        return this.car ;    &#125;    public String getInfo() &#123;        return &quot;姓名：&quot; + this.name + &quot;、年龄：&quot; + this.age ;    &#125;&#125;public class Demo &#123;    public static void main(String args[]) &#123;        //声明对象并且设置彼此的关系        Person person = new Person(&quot;Mr.lin&quot;,29) ;        Car car = new Car(&quot;binli&quot;,10) ;        person.setCar(car) ;//一个人有一辆车        car.setPerson(person) ;//一辆车属于一个人        //第二部：根据关系获取数据        System.out.println(person.getCar().getInfo()) ;//代码链        System.out.println(car.getPerson().getInfo()) ;//代码链    &#125;&#125;\n\n自身关联class Car &#123;    private String name ;    private double price ;    private Person person ;//一辆车属于一个人    public Car(String name,double price) &#123;        this.name = name ;        this.price = price ;    &#125;    public void setPerson(Person person) &#123;        this.person = person ;    &#125;    public Person getPerson() &#123;        return this.person ;     &#125;    public String getInfo() &#123;        return &quot;汽车品牌号&quot; + this.name + &quot;、汽车价格:&quot; + this.price ;    &#125;&#125;class Person &#123;    private String name ;    private int age ;    private Car car ;//一个人有一辆车    private Person children [] ;//一个人有多个孩子    public void setChildren (Person children[]) &#123;        this.children = children ;    &#125;    public Person [] getChildren() &#123;        return children ;    &#125;    public Person(String name,int age) &#123;        this.name = name ;        this.age = age ;    &#125;    public void setCar(Car car) &#123;        this.car = car ;    &#125;    public Car getCar() &#123;        return this.car ;    &#125;    public String getInfo() &#123;        return &quot;姓名：&quot; + this.name + &quot;、年龄：&quot; + this.age ;    &#125;&#125;public class Demo &#123;    public static void main(String args[]) &#123;        //声明对象并且设置彼此的关系        Person person = new Person(&quot;Mr.lin&quot;,29) ;        Person childA = new Person(&quot;AA&quot;,10) ;        Person childB = new Person(&quot;BB&quot;,13) ;        childA.setCar(new Car(&quot;X&quot;,100)) ;        childB.setCar(new Car(&quot;XX&quot;,1000)) ;        person.setChildren(new Person [] &#123;childA,childB&#125;) ;        Car car = new Car(&quot;binli&quot;,10) ;        person.setCar(car) ;//一个人有一辆车        car.setPerson(person) ;//一辆车属于一个人        //第二部：根据关系获取数据        System.out.println(person.getCar().getInfo()) ;//代码链        System.out.println(car.getPerson().getInfo()) ;//代码链        for(int i = 0 ; i &lt; person.getChildren().length ; i++) &#123;            System.out.println(&quot;\\t|-&quot; + person.getChildren()[i].getInfo()) ;            System.out.println(&quot;\\t\\t|-&quot; + person.getChildren()[i].getCar().getInfo()) ;        &#125;    &#125;&#125;\n\n数据表与简单Java类映射转换映射转换\n数据实体表设计 = 类的定义\n表中的字段 = 类的成员属性\n表的外键关联 = 引用关联\n表的一行记录 = 类的一个实例化对象\n表的多行记录 = 对象数组\n\n​        对于数据表与简单Java类之间的映射最好的解决步骤：先抛开所有的关联字段不看，写出类的基本组成，而后通过引用配置关联字段的关系\n一对多映射class Item &#123;    private long iid ;    private String title ;    private Subitem subitems [] ;    public Item(long iid ,String title) &#123;        this.title = title ;        this.iid = iid ;    &#125;    public void setSubitems(Subitem subitems[]) &#123;        this.subitems = subitems ;    &#125;    public Subitem [] getSubitems() &#123;        return this.subitems ;    &#125;    public String getInfo() &#123;        return &quot;【分类信息】iid = &quot; + this.iid + &quot;title = &quot; + this.title ;      &#125;&#125;class Subitem &#123;    private long sid ;    private String title ;    private Item item ;    public Subitem(long sid,String title) &#123;        this.sid = sid ;        this.title = title ;    &#125;    public void setItem(Item item) &#123;        this.item = item ;    &#125;    public Item getItem() &#123;        return this.item ;    &#125;    public String getInfo() &#123;        return &quot;【自分类信息】sid = &quot; + this.sid + &quot;title = &quot; + this.title ;    &#125;&#125;public class Demo &#123;    public static void main(String args[]) &#123;        //第一步：根据结构设置对象数据        Item item = new Item(1L,&quot;图书&quot;) ;        Subitem subitems [] = new Subitem [] &#123;            new Subitem(10L,&quot;编程图书&quot;),            new Subitem(10L,&quot;图形图像类图书&quot;)        &#125; ;        item.setSubitems(subitems) ;        for(int i = 0 ; i &lt; subitems.length ; i++) &#123;            //第二部：根据要求获取数据            subitems[i].setItem(item) ;        &#125;        System.out.println(item.getInfo()) ;        for(int i = 0 ; i &lt; item.getSubitems().length ; i++) &#123;            System.out.println(&quot;\\t&quot;+item.getSubitems()[i].getInfo()) ;        &#125;    &#125;&#125;\n\n多对多映射class Member &#123;    private String mid ;    private String name ;    private Product products [] ;//多对多不管中间记录表    public Member(String mid,String name) &#123;        this.mid = mid ;        this.name = name ;    &#125;    public void setProducts(Product products []) &#123;        this.products = products ;    &#125;    public Product [] getProducts() &#123;        return this.products ;    &#125;    public String getInfo() &#123;        return &quot;【用户信息】mid = &quot; + this.mid + &quot;      name = &quot; + this.name ;    &#125;&#125;class Product &#123;    private long pid ;    private String title ;    private double price ;    private Member members [] ;    public Product(long pid,String title,double price) &#123;        this.pid = pid ;        this.title = title ;        this.price = price ;    &#125;    public void setMembers (Member members []) &#123;        this.members = members ;    &#125;    public Member [] getMembers () &#123;        return this.members ;    &#125;    public String getInfo() &#123;        return &quot;【商品信息】pid = &quot; + this.pid +&quot;       title = &quot; + this.title + &quot;      price = &quot; + this.price ;    &#125;&#125;public class Demo &#123;    public static void main(String args[]) &#123;        //设置结构设置对象数据        Member memA = new Member(&quot;mldn&quot;,&quot;Davi&quot;) ;        Member memB = new Member(&quot;mlnjava&quot;,&quot;Michael&quot;) ;                //注意此处1L、2L、3L        Product proA = new Product(1L,&quot;Java开发图书&quot;,79.8) ;//此处1L表示1是长整型        Product proB = new Product(2L,&quot;耳机&quot;,1499) ;//如果为1f则为float型        Product proC = new Product(3L,&quot;小米手机&quot;,1999) ;//1L就是1        memA.setProducts(new Product[] &#123;proA,proB,proC&#125;) ;        memB.setProducts(new Product[] &#123;proA&#125;) ;        proA.setMembers(new Member[] &#123;memA,memB&#125;) ;        proB.setMembers(new Member[] &#123;memA&#125;) ;        proC.setMembers(new Member[] &#123;memA&#125;) ;        //第二部：根据要求获取数据        System.out.println(&quot;--------根据用户查看浏览商品信息---------&quot;) ;        System.out.println(memA.getInfo()) ;        for(int i = 0 ; i &lt; memA.getProducts().length ; i++) &#123;            System.out.println(&quot;\\t&quot; + memA.getProducts()[i].getInfo()) ;        &#125;        System.out.println(&quot;--------根据商品查看浏览用户信息---------&quot;) ;         System.out.println(proA.getInfo()) ;        for(int i = 0 ; i &lt; proA.getMembers().length ; i++) &#123;            System.out.println(&quot;\\t&quot; + proA.getMembers()[i].getInfo()) ;        &#125;    &#125;&#125;\n\n复杂多对多映射根据要求实现如下功能：\n\n可以根据一个用户找到该用户对应的所有角色，以及每一个角色对应的所有权限信息；\n可以根据一个角色找到该角色下的所有权限，以及拥有此角色的全部用户信息；\n可以根据一个权限找到具备此权限所有用户信息\n\nclass Member &#123;    private String mid ;    private String name ;    private Role roles [] ;    public Member(String mid,String name) &#123;        this.mid = mid ;        this.name = name ;    &#125;    public void setRoles(Role roles[]) &#123;        this.roles = roles ;    &#125;    public Role [] getRoles() &#123;        return this.roles ;    &#125;    public String getInfo() &#123;        return &quot;【用户信息】id = &quot; + this.mid + &quot;\t\tname = &quot; + this.name ;    &#125;&#125;class Role &#123;    private long rid ;    private String title ;    private Privilege privileges [] ;    private Member members [] ;    public Role(long rid,String title) &#123;        this.rid = rid ;        this.title = title ;    &#125;    public void setPrivileges(Privilege privileges[]) &#123;        this.privileges = privileges ;     &#125;    public Privilege [] getPrivileges() &#123;        return this.privileges ;    &#125;    public void setMembers(Member members[]) &#123;        this.members = members ;    &#125;    public Member [] getMembers() &#123;        return this.members ;    &#125;    public String getInfo() &#123;        return &quot;【角色信息】id = &quot; + this.rid + &quot;\t\ttitle = &quot; + this.title ;    &#125;&#125;class Privilege &#123;    private long pid ;    private String title ;    private Role role ;    private Member members [] ;    public Privilege(long pid,String title) &#123;        this.pid = pid ;        this.title = title ;    &#125;    public void setRole(Role role)&#123;        this.role = role ;    &#125;    public Role getRole()&#123;        return this.role ;    &#125;    public void setMembers(Member members[]) &#123;        this.members = members ;    &#125;    public Member [] getMembers() &#123;        return this.members ;    &#125;    public String getInfo() &#123;        return &quot;【权限信息】id = &quot; + this.pid + &quot;\t\ttitle = &quot; + this.title ;    &#125;&#125;public class Demo &#123;    public static void main(String args[]) &#123;        Member memA = new Member(&quot;a&quot;,&quot;Bob&quot;) ;        Member memB = new Member(&quot;b&quot;,&quot;kang&quot;) ;        Role roleA = new Role(1L,&quot;系统配置&quot;) ;        Role roleB = new Role(2L,&quot;备份管理&quot;) ;        Role roleC = new Role(3L,&quot;人事管理&quot;) ;        Privilege priA = new Privilege (1000L,&quot;系统初始化&quot;) ;        Privilege priB = new Privilege (1001L,&quot;系统系统还原&quot;) ;        Privilege priC = new Privilege (1002L,&quot;系统环境修改&quot;) ;          Privilege priD = new Privilege (2000L,&quot;备份员工数据&quot;) ;        Privilege priE = new Privilege (2001L,&quot;备份部门数据&quot;) ;        Privilege priF = new Privilege (2002L,&quot;备份公文数据&quot;) ;        Privilege priG = new Privilege (3000L,&quot;增加员工&quot;) ;\t\tPrivilege priH = new Privilege (3001L,&quot;编辑员工&quot;) ;        Privilege priI = new Privilege (3002L,&quot;浏览员工&quot;) ;\t\tPrivilege priJ = new Privilege (3003L,&quot;员工离职&quot;) ;        roleA.setMembers(new Member[] &#123;memA,memB&#125;) ;        roleB.setMembers(new Member[] &#123;memA,memB&#125;) ;        roleC.setMembers(new Member[] &#123;memB&#125;) ;        //增加角色与权限对应关系\t\troleA.setPrivileges(new Privilege[] &#123;priA,priB,priC&#125;) ;        roleB.setPrivileges(new Privilege[] &#123;priD,priE,priF&#125;) ;        roleC.setPrivileges(new Privilege[] &#123;priG,priH,priI,priJ&#125;) ;        //增加权限与角色对应        priA.setRole(roleA) ;        priB.setRole(roleA) ;        priC.setRole(roleA) ;        priD.setRole(roleB) ;        priF.setRole(roleB) ;        priG.setRole(roleB) ;        priH.setRole(roleC) ;        priI.setRole(roleC) ;        priJ.setRole(roleC) ;        //增加用户与角色对应        memA.setRoles(new Role[] &#123;roleA,roleB&#125;) ;        memB.setRoles(new Role[] &#123;roleA,roleB,roleC&#125;) ;        roleA.setMembers(new Member[] &#123;memA,memB&#125;) ;        roleB.setMembers(new Member[] &#123;memA,memB&#125;) ;        roleC.setMembers(new Member[] &#123;memB&#125;) ;        System.out.println(&quot;---------通过用户查找信息----------&quot;) ;        System.out.println(memB.getInfo()) ;        for(int x = 0 ; x &lt; memB.getRoles().length ; x++)&#123;            System.out.println(&quot;\\t&quot; + memB.getRoles()[x].getInfo()) ;            for(int y = 0 ; y &lt; memB.getRoles()[x].getPrivileges().length ; y++)&#123;                System.out.println(&quot;\\t\\t&quot; + memB.getRoles()[x].getPrivileges()[y].getInfo()) ;            &#125;        &#125;        System.out.println(&quot;---------通过角色查找信息----------&quot;) ;        System.out.println(roleB.getInfo()) ;        System.out.println(&quot;\\t 浏览此角色下的所有权限信息:&quot;) ;        for(int x = 0 ; x &lt; roleB.getPrivileges().length ; x++)&#123;            System.out.println(&quot;\\t&quot; + roleB.getPrivileges()[x].getInfo()) ;        &#125;        System.out.println(&quot;\\t 浏览此角色下的所有用户信息:&quot;) ;        for(int x = 0 ; x &lt; roleB.getMembers().length ; x++) &#123;            System.out.println(&quot;\\t &quot;+ roleB.getMembers()[x].getInfo()) ;        &#125;        System.out.println(&quot;---------通过权限查找信息----------&quot;) ;        System.out.println(priA.getInfo()) ;        for(int x = 0 ;x &lt; priA.getRole().getMembers().length ; x++)&#123;            System.out.println(&quot;\\t&quot; + priA.getRole().getMembers()[x].getInfo()) ;        &#125;    &#125;&#125;\n\nString类特点分析String类简介字符串严格意义上说不能算是基本数据类型，也就是说没有任何一门语言会提供有字符串这种数据类型，而Java里面为了方便开发者进行项目的编写，利用JVM的支持制造了一种可以简单使用的String类。\nString本身包装的是一个数组，并且其有两种对象的实例化形式\n\n直接赋值\n构造方法实例化\n\npublic class Demo &#123;    public static void main(String[] args) &#123;        String str1 = &quot;BearKouber.github.io&quot; ;//直接赋值        System.out.println(str1) ;        String str2 = new String (&quot;BearKouber.github.io&quot;) ;//构造方法实例化\t\tSystem.out.println(str2) ;    &#125;&#125;\n\n\n\n\nJDK1.8之前String保存的是字符数组\nJDK1.9以后String保存的是字节数组\n\n\n\nprivate final char value[];\nprivate final byte[] value\n\n\n所谓的字符串就是对数组的一种特殊包装应用；\n注意：因为包装的是数组，所以字符串里面的内容是肯定无法改变的\n字符串比较String可以像基本数据类型一样进行判断(==)，但是判断结果不准确\npublic class Demo &#123;    public static void main(String[] args) &#123;        String strA = &quot;kouber&quot; ;        String strB = new String (&quot;kouber&quot;) ;        System.out.println(strA == strB) ;//false    &#125;&#125;\n\n想要获得准确判断结果可以使用String类中提供的一个比较方法：\npublic boolean equals(String str);//有变形\n\npublic class Demo &#123;    public static void main(String[] args) &#123;        String strA = &quot;kouber&quot; ;        String strB = new String (&quot;kouber&quot;) ;        System.out.println(strA.equals(strB)) ;//true    &#125;&#125;\n\n比较String与equals()的区别 \n\n==比较的是数值比较，如果用于对象比较上比较的是两个内存的地址数值，而new是会分配新的地址空间，因此使用”==”就会出现错误判断结果；\nequals() 是类所提供的一个比较方法，可以直接进行字符串内容的判断\n\n字符串常量是String类的匿名对象首先程序之中不会提供有字符串这样的基本数据类型，那么可以提供的只是String类，所以任何使用&quot;定义的字符串常量实际上描述的都是一个String类的匿名对象。\npublic class Demo &#123;    public static void main(String[] args) &#123;        String str = &quot;kouber&quot; ;        System.out.println(&quot;kouber&quot;.equals(str)) ;//true    &#125;&#125;\n\n所谓的String类对象的直接赋值直接描述的是，将一个匿名对象设置一个具体的引用名字。\n观察匿名对象的存在：\npublic class Demo &#123;    public static void main(String[] args) &#123;        String str = &quot;kouber&quot; ;        System.out.println(&quot;kouber&quot;.equals(str)) ; //true    &#125;&#125;\n\n此时可以发现字符串常量已经可以明确的调用equals()方法实现对象相等的判断，所以可以得出结论：程序中的确没有字符串常量，有的只是String类的匿名对象。\n关于对象相等判断的小技巧:\n在以后进行项目开发的时候，如果现在某些数据是由用户输入，并且要求这些这些数据为一个指定内容情况下，建议将字符串常量写在前面。\n\n接收用户输入数据的字符串调用方法\n\n当输入不为空时\n\npublic class Demo &#123;    public static void main(String[] args) &#123;        String str = &quot;kouber&quot; ; //str为用户输入的内容        System.out.println(str.equals(&quot;kouber&quot;)) ; //true    &#125;&#125;\n\n\n\n\n当输入为空时\n\npublic class Demo &#123;    public static void main(String[] args) &#123;        String str = null ; //str为用户输入的内容        System.out.println(str.equals(&quot;null&quot;)) ; //报错：Exception in thread &quot;main&quot; java.lang.NullPointerException    &#125;&#125;\n将字符串对象写在前面\n\n\npublic class Demo &#123;    public static void main(String[] args) &#123;        String str = null ; //str为用户输入的内容        System.out.println(&quot;kouber&quot;.equals(str)) ; //false    &#125;&#125;\n\nequals()方法里面提供有一个可以回避null的判断，如果将字符串常量写在前面，那么调用equals()方法的时候永远都不可能出现NullPointerException,字符串是一个匿名对象，匿名对象一定是开辟好堆内存空间的对象。\nString类对象两种实例化方式比较分析直接赋值的对象实例化模式在程序之中只需要把字符串赋值给String对象就可以实现对象的实例化处理\n这种情况下肯定只会开辟出一块堆内存空间\npublic class Demo &#123;    public static void main(String[] args) &#123;        String str = &quot;kouber&quot; ;     &#125;&#125;\n\n除了这种内存模式之外，利用直接赋值实例化String的形式还可以实现同一个字符串对象数据的共享操作。\n观察String直接赋值时的数据共享\npublic class Demo &#123;    public static void main(String[] args) &#123;        String strA = &quot;kouber&quot; ;        String strB = &quot;kouber&quot; ;        System.out.println(strA == strB) ;//“==”为地址判断    &#125;//true&#125;\n\n结论：这两个对象所指的堆内存空间是同一个\n即在两个String变量的值相等时\n占两个堆内存空间，一个栈内存空间，strA和strB所指向的地址相同\n\n\n\n堆内存\n栈内存\n\n\n\nstrA\nkouber\n\n\nstrB\n\n\n\n为什么不是在堆空间中开辟两个”kouber“对象而是让strA和strB指向同一个对象呢？\n这个需要谈到JVM的共享设计模式。\nJVM的底层实现实际上在堆中存在一个对象池（常量池，不一定只保存String对象,池就是一个在堆内存中的数组，），当我们使用直接赋值方式定义String类对象，那么JVM会将此字符串对象使用的匿名对象就是如”kouber“字符串入池保存。如果后面还有其他String对象采用同样方式且设置同样内容时，将不会开辟新的堆空间，而是继续使用相同的空间\n分析构造方法实例化会开辟两块堆空间，一块在常量池中存储”kouber“字符串常量另一块在堆中存储这个对象。\n而str指向的是对象的地址而不是常量池中”kouber“的地址\npublic class Demo &#123;    public static void main(String[] args) &#123;        String str = new String(&quot;kouber&quot;) ;    &#125;&#125;\n\n这样就会造成一块堆内存空间的浪费(常量池中)\n如果常量池中已存在要使用构造方法定义的字符串，那么只会开辟一个堆内存空间来储存对象\n即下面一共开辟了两个堆内存空间\n一个常量池中的空间储存”kouber“字符串，和另一个堆内存空间储存这个对象。\npublic class Demo &#123;    public static void main(String[] args) &#123;        String strA = &quot;kouber&quot; ;        String strB = new String(&quot;kouber&quot;) ;        System.out.println(strA == strB) ;    &#125;&#125;\n\n\n\n让该对象入池的方法(String类的intern方法)\npublic class Demo &#123;    public static void main(String[] args) &#123;        String strA = &quot;kouber&quot; ;        String strB = new String(&quot;kouber&quot;).intern() ;        System.out.println(strA == strB) ;//true    &#125;&#125;\n\n\n\n总结一下两种实例化方法的区别：\n直接赋值方式：只会开辟一块堆内存空间，并且自动保存在常量池中，以供我们下次重复使用。\n构造方法：会开辟两块堆内存空间，其中在常量池的会成为垃圾空间，不会自动入池，不会实现对象重用，可以使用intern()方法手工入池。\n\nString对象常量池实现数据的共享处理。\n以String对象池为例，里面的内容主要就是为了重用，而重用就是共享设计。\n在Java之中的对象(常量)池可以分为两种\n\n静态常量池：指的是程序在加载时候会自动将此程序之中保存全部信息全部进行分配提供的常量池。\n运行时常量池：指的是当一个程序加载只后，里面可能有一些变量需要用户输入后接收，这个时候提供的常量池。\n\nstrB储存在静态常量池中\npublic class Demo &#123;    public static void main(String[] args) &#123;        String strA = &quot;kouber&quot; ;        String strB = &quot;kou&quot; + &quot;ber&quot; ;        //String strB = &quot;kouber&quot; ; 上面代码跟这行效果一样        System.out.println(strA == strB) ;//true    &#125;&#125;\n\n上述代码中所给出的内容全部都是静态常量数据(字符串的常量都是匿名对象)，所以程序开发中会帮设计者处理好相应的连接\nstrB储存在运行时常量池中\npublic class Demo &#123;    public static void main(String[] args) &#123;        String strK = &quot;kou&quot; ;        String strA = &quot;kouber&quot; ;        String strB = strK + &quot;ber&quot; ;        System.out.println(strA == strB) ;//false    &#125;&#125;\n\n程序加载时候不确定strK是什么内容。在字符串进行连接的时候，strK是一个变量，变量的内容是可以修改的，所以程序不认为strB的结果就是最终的结果\n结论：遇见变量数据时，最终比较变量时需要使用equals()\n字符串修改分析String定义之后无法修改\npublic class Demo &#123;    public static void main(String[] args) &#123;        String str = &quot;bear&quot; ;        str += &quot;kou&quot; ;        str += &quot;ber&quot; ;        System.out.println(str) ;//bearkouber    &#125;&#125;\n\n为什么上面代码看似是修改了String变量\n\n\n\n栈内存\n堆内存\n\n\n\nstr\nbear\n\n\n\nkou\n\n\n\nbearkou\n\n\n\nber\n\n\n\nbearkouber\n\n\n对str内容的修实际上是str指针指向的变化：\n\n指向bear\n指向bearkou\n指向bearkouber\n\n这样做造成的结果为：\n堆内存bear、kou、bearkou、ber将成为垃圾内存空间，string对象的指向修改了2次。\n在开发中频繁对String类内容进行修改会使程序的性能变得很差\n主方法组成分析public static void main(String[] args)\n\n\npublic:描述 的是一种访问权限，主方法是一切的开始点，开始点一定是公共的；\nstatic:程序的执行是通过类名称完成的，所以此方法是由类直接调用;\nvoid:主方法是一切的起点，起点一旦开始就没有返回的可能；\nmain:是一个系统定义好的方法名称；\nString[] args:字符串的数组，可以实现程序启动参数的接收\n\n在程序执行时候可以设置参数，每一个参数之间使用空格分割\npublic class Demo &#123;    public static void main(String[] args) &#123;        for(String arg:args)&#123;            System.out.println(arg) ;        &#125;    &#125;&#125;\n\n&gt;javac Demo.java&gt;java Demo first secondfirstsecond\n\n注意：如果参数含空格，则必须使用“””包装\npublic class Demo &#123;    public static void main(String[] args) &#123;        for(String arg:args)&#123;            System.out.println(arg) ;        &#125;    &#125;&#125;\n\n&gt;javac Demo.java&gt;java Demo&quot;Hello World!&quot;Hello World!\n\n"}]